name: 'Release update (Flow)'

on:
#   workflow_call:
  workflow_dispatch:
    inputs:
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      release_branch:
        description: 'Release branch to scan (e.g., R1-2025)'
        required: true
        type: string
      update_branch:
        description: 'Update branch name for this release branch'
        required: true
        type: string
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      dry_run:
        description: 'Perform dry run without creating PRs'
        required: false
        type: boolean
        default: false
      pr_reviewers:
        description: 'Comma-separated list of reviewers (users or teams with org/ prefix)'
        required: false
        type: string
        default: ''
      pr_labels:
        description: 'Comma-separated list of labels to add to PR'
        required: false
        type: string
        default: ''
#     outputs:
#       pr_created:
#         description: 'Whether a PR was created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_created || jobs.manage-pr.outputs.pr_updated }}
#       pr_number:
#         description: 'PR number if created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_number }}
#       pr_url:
#         description: 'PR URL if created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_url }}
#       successful_reviewers:
#         description: 'Successfully added reviewers'
#         value: ${{ jobs.manage-pr.outputs.successful_reviewers }}
#       failed_reviewers:
#         description: 'Failed to add reviewers'
#         value: ${{ jobs.manage-pr.outputs.failed_reviewers }}
#       updated:
#         description: 'Whether the platform descriptor was updated'
#         value: ${{ jobs.update-platform.outputs.updated }}
#       new_version:
#         description: 'New platform version if updated'
#         value: ${{ jobs.update-platform.outputs.new_version }}
#       updates_cnt:
#         description: 'Number of updates'
#         value: ${{ jobs.update-platform.outputs.updates_cnt }}
#       workflow_status:
#         description: 'Overall workflow status'
#         value: ${{ jobs.determine-source-branch.result == 'failure' && 'failure' || (jobs.update-platform.result == 'failure' && 'failure' || (jobs.commit-changes.result == 'failure' && 'failure' || (jobs.manage-pr.result == 'failure' && 'failure' || 'success'))) }}
#       failure_reason:
#         description: 'Reason for workflow failure if any'
#         value: ${{ jobs.determine-source-branch.result == 'failure' && 'Failed to determine source branch' || (jobs.update-platform.result == 'failure' && 'Failed to update application modules' || (jobs.update-platform.result == 'skipped' && 'Update application job was skipped' || (jobs.commit-changes.result == 'failure' && 'Failed to commit changes to branch' || (jobs.manage-pr.result == 'failure' && 'Failed to manage pull request' || '')))) }}

permissions:
  contents: write
  pull-requests: write

# Prevent overlapping runs for the same repo / release & update branch combination
concurrency:
  group: release-update-${{ inputs.repo }}-${{ inputs.release_branch }}-${{ inputs.update_branch }}
  cancel-in-progress: true

# Consistent shell usage & safer defaults
defaults:
  run:
    shell: bash

env:
  STATE_FILE: platform-descriptor.json
  FAR_URL: 'https://far.ci.folio.org'
  ARTIFACT_NAME: platform-lsp-update-files
  GH_TOKEN: ${{ github.token }}

jobs:
  determine-source-branch:
    name: 'Determine Source Branch and PR Status'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      source_branch: ${{ steps.determine-branch.outputs.source_branch }}
      update_branch_exists: ${{ steps.determine-branch.outputs.update_branch_exists }}
      pr_exists: ${{ steps.check-pr.outputs.pr_exists }}
      pr_number: ${{ steps.check-pr.outputs.pr_number }}
      pr_url: ${{ steps.check-pr.outputs.pr_url }}
    steps:
      - name: 'Determine which branch to scan'
        id: determine-branch
        env:
          REPO: ${{ inputs.repo }}
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          UPDATE_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo "::notice::Checking if update branch exists: $UPDATE_BRANCH"
          if gh api "repos/$REPO/branches/$UPDATE_BRANCH" >/dev/null 2>&1; then
            echo "::notice::Update branch exists, will scan: $UPDATE_BRANCH"
            echo "source_branch=$UPDATE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::Update branch does not exist, will scan: $RELEASE_BRANCH"
            echo "source_branch=$RELEASE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: 'Check for existing PR'
        id: check-pr
        if: steps.determine-branch.outputs.update_branch_exists == 'true'
        env:
          REPO: ${{ inputs.repo }}
          BASE_BRANCH: ${{ inputs.release_branch }}
          HEAD_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo "::notice::Checking for existing PR from $HEAD_BRANCH to $BASE_BRANCH"
          pr_json=$(gh pr list \
            --repo "$REPO" \
            --base "$BASE_BRANCH" \
            --head "$HEAD_BRANCH" \
            --json number,url \
            --jq '.[0]' || echo '{}')
          if [ "$pr_json" != "{}" ] && [ -n "$pr_json" ] && [ "$(echo "$pr_json" | jq -r '.url // ""')" != "" ]; then
            pr_number=$(echo "$pr_json" | jq -r '.number // ""')
            pr_url=$(echo "$pr_json" | jq -r '.url // ""')
            echo "::notice::Found existing PR #$pr_number: $pr_url"
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::No existing PR found"
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
            echo "pr_number=" >> "$GITHUB_OUTPUT"
            echo "pr_url=" >> "$GITHUB_OUTPUT"
          fi

  update-platform:
    name: 'Read & Update Platform Descriptor'
    needs: determine-source-branch
    runs-on: ubuntu-latest
    outputs:
      updated: ${{ steps.calculate-new-version.outputs.updated }}
      updated_components: ${{ steps.compare-components.outputs.updated_eureka_components }}
      updated_applications: ${{ steps.compare-components.outputs.updated_applications }}
      updated_report: ${{ steps.build-change-report.outputs.updated_report }}
      new_version: ${{ steps.calculate-new-version.outputs.new_version }}
      updates_cnt: ${{ steps.build-change-report.outputs.updates_cnt }}
      artifact_name: ${{ env.ARTIFACT_NAME }}
      failure_reason: ${{ steps.calculate-new-version.outputs.failure_reason }}
      updates_markdown: ${{ steps.generate-markdown-reports.outputs.updates_markdown }}
      ui_updates_markdown: ${{ steps.generate-markdown-reports.outputs.ui_updates_markdown }}
      missing_ui_markdown: ${{ steps.generate-markdown-reports.outputs.missing_ui_markdown }}
    steps:
      - name: 'Checkout Platform Repository'
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ needs.determine-source-branch.outputs.source_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 'Fetch and save base branch descriptor'
        id: fetch-base-descriptor
        env:
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          STATE_FILE: ${{ env.STATE_FILE }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo "::notice::Fetching base descriptor from release branch: $RELEASE_BRANCH"
          git fetch origin "$RELEASE_BRANCH" --depth=1
          BASE_STATE_FILE="platform-descriptor.base.json"
          if ! git show "origin/$RELEASE_BRANCH:$STATE_FILE" > "$BASE_STATE_FILE" 2>/dev/null; then
            echo "::error::Failed to fetch $STATE_FILE from base branch $RELEASE_BRANCH"
            exit 1
          fi
          if [ ! -s "$BASE_STATE_FILE" ]; then
            echo "::error::Base descriptor file is empty"
            exit 1
          fi
          if ! jq empty "$BASE_STATE_FILE" 2>/dev/null; then
            echo "::error::Base descriptor is not valid JSON"
            cat "$BASE_STATE_FILE"
            exit 1
          fi
          echo "base_state_file=$BASE_STATE_FILE" >> "$GITHUB_OUTPUT"
          echo "::notice::Base descriptor saved to $BASE_STATE_FILE"

      - name: 'Read descriptor file'
        id: read-descriptor
        env:
          SOURCE_BRANCH: ${{ needs.determine-source-branch.outputs.source_branch }}
          STATE_FILE: ${{ env.STATE_FILE }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo '::notice::Reading descriptor file from checked-out branch: '$SOURCE_BRANCH
          if [ ! -f "$STATE_FILE" ] || [ ! -s "$STATE_FILE" ]; then
            echo "::error::Descriptor file '$STATE_FILE' is missing or empty in branch '$SOURCE_BRANCH'"
            ls -al || true
            exit 1
          fi
          for field in eureka-components applications; do
            if ! jq -e "has(\"$field\")" "$STATE_FILE" >/dev/null; then
              echo "::error::Descriptor file does not contain '$field' field"
              echo 'File content:' && cat "$STATE_FILE"
              exit 1
            fi
          done
          EUREKA_COMPONENTS=$(jq -c '."eureka-components"' "$STATE_FILE")
          {
            echo 'eureka_components<<EOF'
            echo "$EUREKA_COMPONENTS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")
          {
            echo 'applications<<EOF'
            echo "$APPLICATIONS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          echo '::notice::Extracted eureka-components and applications from descriptor file'

      - name: 'Update Eureka Components'
        id: update-eureka-components
        uses: folio-org/platform-lsp/.github/actions/update-eureka-components@RANCHER-2324
        with:
          components: ${{ steps.read-descriptor.outputs.eureka_components }}

      - name: 'Update Applications'
        id: update-applications
        uses: folio-org/platform-lsp/.github/actions/update-applications@RANCHER-2324
        with:
          applications: ${{ steps.read-descriptor.outputs.applications }}

      - name: 'Compare Components & Applications'
        id: compare-components
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          UPDATED_EUREKA_COMPONENTS: ${{ steps.update-eureka-components.outputs.updated-components }}
          UPDATED_APPLICATIONS: ${{ steps.update-applications.outputs.updated-applications }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo '::notice::Comparing descriptor eureka-components & applications with updated results'
          PREVIOUS_VERSION=$(jq -r '.version // "unknown"' "$STATE_FILE")
          CURRENT_EUREKA_COMPONENTS=$(jq -c '."eureka-components"' "$STATE_FILE")
          CURRENT_APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")
          changes_detected=false
          if [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA_COMPONENTS" ] || [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPLICATIONS" ]; then
            changes_detected=true
            [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA_COMPONENTS" ] && echo '::notice::Eureka components changed'
            [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPLICATIONS" ] && echo '::notice::Applications changed'
          fi
          echo "previous_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"
          echo "changes_detected=$changes_detected" >> "$GITHUB_OUTPUT"
          {
            echo 'current_eureka_components<<EOF'
            echo "$CURRENT_EUREKA_COMPONENTS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'current_applications<<EOF'
            echo "$CURRENT_APPLICATIONS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'updated_eureka_components<<EOF'
            echo "$UPDATED_EUREKA_COMPONENTS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'updated_applications<<EOF'
            echo "$UPDATED_APPLICATIONS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: 'Calculate New Version'
        id: calculate-new-version
        env:
          PREVIOUS_VERSION: ${{ steps.compare-components.outputs.previous_version }}
          CHANGES_DETECTED: ${{ steps.compare-components.outputs.changes_detected }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          UPDATED=false
          FAILURE_REASON=''
          NEW_VERSION="$PREVIOUS_VERSION"
          if [ "$CHANGES_DETECTED" = 'true' ]; then
            if [[ "$PREVIOUS_VERSION" =~ ^(R[0-9]+-[0-9]+)\.([0-9]+)$ ]]; then
              BASE_VERSION="${BASH_REMATCH[1]}"
              PATCH_VERSION="${BASH_REMATCH[2]}"
              NEW_VERSION="${BASE_VERSION}.$((PATCH_VERSION + 1))"
              UPDATED=true
              echo "::notice::Calculated new version $NEW_VERSION from previous $PREVIOUS_VERSION"
            else
              FAILURE_REASON="Previous version '$PREVIOUS_VERSION' does not match expected format 'R<iteration>-<year>.<patch>'"
              echo "::warning::$FAILURE_REASON (no update applied)"
              UPDATED=false
            fi
          else
            echo '::notice::No component/application changes detected; version unchanged'
          fi
          echo "updated=$UPDATED" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "failure_reason=$FAILURE_REASON" >> "$GITHUB_OUTPUT"

      - name: 'Apply Descriptor Updates'
        id: apply-updates
        if: steps.calculate-new-version.outputs.updated == 'true'
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          NEW_VERSION: ${{ steps.calculate-new-version.outputs.new_version }}
          UPDATED_EUREKA_COMPONENTS: ${{ steps.compare-components.outputs.updated_eureka_components }}
          UPDATED_APPLICATIONS: ${{ steps.compare-components.outputs.updated_applications }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo '::notice::Applying descriptor updates'
          # Simple in-place update without reordering logic; Python update scripts now preserve original key order.
          jq --arg version "$NEW_VERSION" \
             --argjson components "$UPDATED_EUREKA_COMPONENTS" \
             --argjson applications "$UPDATED_APPLICATIONS" '.version = $version | ."eureka-components" = $components | .applications = $applications' "$STATE_FILE" > "${STATE_FILE}.tmp"
          mv "${STATE_FILE}.tmp" "$STATE_FILE"
          echo '::notice::Descriptor file updated'
          echo 'applied=true' >> "$GITHUB_OUTPUT"

      - name: 'Build Collapsed Diff Report (Base vs Head)'
        id: build-change-report
        env:
          BASE_STATE_FILE: ${{ steps.fetch-base-descriptor.outputs.base_state_file }}
          STATE_FILE: ${{ env.STATE_FILE }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo '::notice::Building collapsed diff between base and head descriptors'

          # Function to collapse changes for a given list (base vs head)
          collapse_lists() {
            local base_json="$1"
            local head_json="$2"
            local label="$3"
            jq -n \
              --argjson B "$base_json" \
              --argjson H "$head_json" \
              --arg label "$label" '
              def to_map: map({key:.name, value:.version}) | from_entries;
              ($B | to_map) as $BM |
              ($H | to_map) as $HM |
              [
                ($BM | keys[]) as $k |
                select(($HM | has($k)) and ($BM[$k] != $HM[$k])) |
                {
                  name: $k,
                  change: { old: $BM[$k], new: $HM[$k] },
                  group: $label
                }
              ]
            '
          }

          # Extract components and applications from base
          BASE_EC=$(jq -c '."eureka-components"' "$BASE_STATE_FILE")
          BASE_REQ=$(jq -c '.applications.required' "$BASE_STATE_FILE")
          BASE_OPT=$(jq -c '.applications.optional' "$BASE_STATE_FILE")

          # Extract components and applications from head
          HEAD_EC=$(jq -c '."eureka-components"' "$STATE_FILE")
          HEAD_REQ=$(jq -c '.applications.required' "$STATE_FILE")
          HEAD_OPT=$(jq -c '.applications.optional' "$STATE_FILE")

          # Build collapsed diffs
          EC_DIFF=$(collapse_lists "$BASE_EC" "$HEAD_EC" "Eureka Components")
          REQ_DIFF=$(collapse_lists "$BASE_REQ" "$HEAD_REQ" "Applications (required)")
          OPT_DIFF=$(collapse_lists "$BASE_OPT" "$HEAD_OPT" "Applications (optional)")

          # Combine all diffs
          COLLAPSED_REPORT=$(jq -n \
            --argjson a "$EC_DIFF" \
            --argjson b "$REQ_DIFF" \
            --argjson c "$OPT_DIFF" \
            '$a + $b + $c')

          UPDATES_CNT=$(jq 'length' <<< "$COLLAPSED_REPORT")

          echo "::notice::Found $UPDATES_CNT total changes between base and head"

          {
            echo 'updated_report<<EOF'
            echo "$COLLAPSED_REPORT"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          echo "updates_cnt=$UPDATES_CNT" >> "$GITHUB_OUTPUT"

      - name: 'Fetch updated UI modules list'
        id: fetch-updated-ui-modules
        if: steps.calculate-new-version.outputs.updated == 'true'
        uses: folio-org/platform-lsp/.github/actions/fetch-updated-ui-modules@RANCHER-2324
        with:
          applications: ${{ steps.compare-components.outputs.updated_applications }}
          far-url: ${{ env.FAR_URL }}

      - name: 'Read package.json content'
        id: read-package-json
        if: steps.calculate-new-version.outputs.updated == 'true'
        env:
          SOURCE_BRANCH: ${{ needs.determine-source-branch.outputs.source_branch }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo "::notice::Reading package.json from checked-out branch: $SOURCE_BRANCH"
          if [ ! -f package.json ] || [ ! -s package.json ]; then
            echo "::error::package.json file is missing or empty in branch '$SOURCE_BRANCH'"
            ls -al || true
            exit 1
          fi
          if ! jq empty package.json 2>/dev/null; then
            echo '::error::package.json is not valid JSON'
            cat package.json
            exit 1
          fi
          PACKAGE_JSON_CONTENT=$(jq -c . package.json)
          {
            echo 'package_json_content<<EOF'
            echo "$PACKAGE_JSON_CONTENT"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          echo '::notice::Read package.json content'

      - name: 'Update package.json dependencies'
        id: update-package-json
        if: steps.calculate-new-version.outputs.updated == 'true' && steps.fetch-updated-ui-modules.outputs.ui-modules != ''
        uses: folio-org/platform-lsp/.github/actions/update-package-json@RANCHER-2324
        with:
          package-json: ${{ steps.read-package-json.outputs.package_json_content }}
          ui-modules: ${{ steps.fetch-updated-ui-modules.outputs.ui-modules }}

      - name: 'Write updated package.json'
        id: write-package-json
        if: steps.update-package-json.outputs.has-updates == 'true'
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          echo "::notice::Writing updated package.json content"
          echo '${{ steps.update-package-json.outputs.package-json }}' | jq . > package.json
          if [ ! -s package.json ]; then
            echo "::error::Failed to write updated package.json"
            exit 1
          fi
          echo "::notice::Successfully updated package.json with ${{ steps.update-package-json.outputs.updated-count }} dependency changes"

      - name: 'Generate Collapsed Markdown Report'
        id: generate-markdown-reports
        env:
          UPDATED: ${{ steps.calculate-new-version.outputs.updated }}
          FAILURE_REASON: ${{ steps.calculate-new-version.outputs.failure_reason }}
          PREVIOUS_VERSION: ${{ steps.compare-components.outputs.previous_version }}
          NEW_VERSION: ${{ steps.calculate-new-version.outputs.new_version }}
          UPDATED_REPORT: ${{ steps.build-change-report.outputs.updated_report }}
          UPDATES_CNT: ${{ steps.build-change-report.outputs.updates_cnt }}
          UPDATED_UI_REPORT: ${{ steps.update-package-json.outputs.updated-ui-report }}
          UPDATED_COUNT: ${{ steps.update-package-json.outputs.updated-count }}
          NOT_FOUND_UI_REPORT: ${{ steps.update-package-json.outputs.not-found-ui-report }}
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          UPDATE_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          render_collapsed_table() {
            local json="$1"
            if [ -z "${json:-}" ] || [ "$json" = "[]" ]; then
              echo ''
              return 0
            fi
            local count
            if ! count=$(jq 'length' <<< "$json" 2>/dev/null); then
              echo ''
              return 0
            fi
            if [ "$count" -eq 0 ]; then
              echo ''
              return 0
            fi
            echo '| Name | Old Version | New Version | Group |'
            echo '| ---- | ----------- | ----------- | ----- |'
            jq -r '.[] | "| \(.name) | \(.change.old) | \(.change.new) | \(.group) |"' <<< "$json"
          }

          render_ui_table() {
            local json="$1"
            if [ -z "${json:-}" ] || [ "$json" = "[]" ]; then
              echo ''
              return 0
            fi
            local count
            if ! count=$(jq 'length' <<< "$json" 2>/dev/null); then
              echo ''
              return 0
            fi
            if [ "$count" -eq 0 ]; then
              echo ''
              return 0
            fi
            echo '| Dependency | Old Version | New Version |'
            echo '| ---------- | ----------- | ----------- |'
            jq -r '.[] | "| \(.name) | \(.change.old) | \(.change.new) |"' <<< "$json"
          }

          render_missing_table() {
            local json="$1"
            if [ -z "${json:-}" ] || [ "$json" = "{}" ]; then
              echo ''
              return 0
            fi
            local count
            if ! count=$(jq 'length' <<< "$json" 2>/dev/null); then
              echo ''
              return 0
            fi
            if [ "$count" -eq 0 ]; then
              echo ''
              return 0
            fi
            echo '| Module | Referenced Version |'
            echo '| ------ | ------------------ |'
            jq -r 'to_entries[] | "| \(.key) | \(.value) |"' <<< "$json"
          }

          if [ "$UPDATED" != 'true' ]; then
            reason='No updates detected.'
            [ -n "${FAILURE_REASON:-}" ] && reason="$FAILURE_REASON"
            descriptor_markdown=$'### Application & Component Updates\n\n'"$reason"
            ui_updates_markdown=$'### UI Dependency Updates\n\nNo UI dependencies were updated.'
            missing_ui_markdown=$'### Missing UI Dependencies\n\nNo missing UI dependencies detected.'
          else
            # Build descriptor changes table
            descriptor_table=$(render_collapsed_table "${UPDATED_REPORT}")
            if [ -z "$descriptor_table" ]; then
              descriptor_markdown=$'### Application & Component Updates\n\n_No changes between base and head descriptor._'
            else
              descriptor_markdown=$(cat <<EOF
          ### Application & Component Updates

          **Base branch:** ${RELEASE_BRANCH}
          **Head branch:** ${UPDATE_BRANCH}
          **Platform version:** ${NEW_VERSION}
          **Changed entries:** ${UPDATES_CNT}

          ${descriptor_table}

          > This table shows the collapsed diff of \`platform-descriptor.json\` between base and head branches.
          EOF
              )
            fi

            # Build UI updates table
            ui_table=$(render_ui_table "${UPDATED_UI_REPORT}")
            if [ -z "$ui_table" ]; then
              ui_updates_markdown=$'### UI Dependency Updates\n\nNo UI dependencies were updated.'
            else
              ui_updates_markdown=$(cat <<EOF
          ### UI Dependency Updates

          **Updated dependencies:** ${UPDATED_COUNT}

          ${ui_table}

          > Changes to \`package.json\` dependencies based on updated application descriptors.
          EOF
              )
            fi

            # Build missing UI table
            missing_table=$(render_missing_table "${NOT_FOUND_UI_REPORT}")
            if [ -z "$missing_table" ]; then
              missing_ui_markdown=$'### Missing UI Dependencies\n\nNo missing UI dependencies detected.'
            else
              missing_cnt=$(jq 'length' <<< "${NOT_FOUND_UI_REPORT}" || echo 0)
              missing_ui_markdown=$(cat <<EOF
          ### Missing UI Dependencies

          **Missing entries:** ${missing_cnt}

          ${missing_table}

          > These UI modules are referenced by application descriptors but were NOT found in \`package.json\`.
          EOF
              )
            fi
          fi

          {
            echo 'updates_markdown<<EOF'
            echo "$descriptor_markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'ui_updates_markdown<<EOF'
            echo "$ui_updates_markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'missing_ui_markdown<<EOF'
            echo "$missing_ui_markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            {
              echo "$descriptor_markdown"
              echo ''
              echo "$ui_updates_markdown"
              echo ''
              echo "$missing_ui_markdown"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: 'Upload Descriptor Artifact'
        if: steps.calculate-new-version.outputs.updated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.ARTIFACT_NAME }}"
          path: |
            ${{ env.STATE_FILE }}
            package.json
          retention-days: 1

  commit-changes:
    name: 'Commit and Push Changes'
    needs: [determine-source-branch, update-platform]
    if: needs.update-platform.outputs.updated == 'true'
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@master
    with:
      repo: ${{ inputs.repo }}
      branch: ${{ inputs.update_branch }}
      artifact_name: ${{ needs.update-platform.outputs.artifact_name }}
      commit_message: |
        Update platform to ${{ needs.update-platform.outputs.new_version }}.

        **Total applications/components updated:** ${{ needs.update-platform.outputs.updates_cnt || '0' }}
        ${{ needs.update-platform.outputs.updates_markdown }}
      dry_run: ${{ inputs.dry_run }}
      use_github_app: true
      source_branch: ${{ needs.determine-source-branch.outputs.source_branch }}
    secrets: inherit

  manage-pr:
    name: 'Manage Pull Request'
    needs: [determine-source-branch, update-platform, commit-changes]
    if: |
      always() &&
      !inputs.dry_run &&
      !cancelled() &&
      needs.update-platform.result == 'success' &&
      (
        needs.update-platform.outputs.updated == 'true' ||
        (
          needs.determine-source-branch.outputs.pr_exists != 'true' &&
          needs.determine-source-branch.outputs.update_branch_exists == 'true'
        )
      )
    runs-on: ubuntu-latest
    outputs:
      pr_created: ${{ steps.create-pr.outputs.pr_created == 'true' }}
      pr_updated: ${{ steps.update-pr.outputs.pr_updated == 'true' }}
      pr_number: ${{ steps.create-pr.outputs.pr_number || steps.update-pr.outputs.pr_number || needs.determine-source-branch.outputs.pr_number || '' }}
      pr_url: ${{ steps.create-pr.outputs.pr_url || steps.update-pr.outputs.pr_url || needs.determine-source-branch.outputs.pr_url || '' }}
      successful_reviewers: ${{ steps.create-pr.outputs.successful_reviewers || steps.update-pr.outputs.successful_reviewers || '' }}
      failed_reviewers: ${{ steps.create-pr.outputs.failed_reviewers || steps.update-pr.outputs.failed_reviewers || '' }}
    steps:
      - name: 'Build collapsed PR body'
        id: build-pr-body
        if: |
          needs.update-platform.outputs.updated == 'true' ||
          needs.determine-source-branch.outputs.update_branch_exists == 'true'
        env:
          NEW_VERSION: ${{ needs.update-platform.outputs.new_version }}
          UPDATES_CNT: ${{ needs.update-platform.outputs.updates_cnt }}
          UPDATES_MARKDOWN: ${{ needs.update-platform.outputs.updates_markdown }}
          UI_UPDATES_MARKDOWN: ${{ needs.update-platform.outputs.ui_updates_markdown }}
          MISSING_UI_MARKDOWN: ${{ needs.update-platform.outputs.missing_ui_markdown }}
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          UPDATE_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          version_display="${NEW_VERSION:-No version change}"
          count_display="${UPDATES_CNT:-0}"

          # Build complete PR body with collapsed report
          pr_body=$(cat <<EOF
          ## Automated Release Update

          **Base branch:** ${RELEASE_BRANCH}
          **Head branch:** ${UPDATE_BRANCH}
          **Platform version:** ${version_display}
          **Total changes:** ${count_display}

          ---

          ${UPDATES_MARKDOWN:-### Application & Component Updates

          No applications or eureka components were updated.}

          ---

          ${UI_UPDATES_MARKDOWN:-### UI Dependency Updates

          No UI dependencies were updated.}

          ---

          ${MISSING_UI_MARKDOWN:-### Missing UI Dependencies

          No missing UI dependencies detected.}

          ---

          > This PR description is auto-generated from a collapsed diff between the base and head branches.
          > Re-running the workflow with the same base/head state produces an identical description.
          EOF
          )

          {
            echo 'pr_body<<EOF'
            echo "$pr_body"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          echo "::notice::Built collapsed PR body (${#pr_body} bytes)"

      - name: 'Create PR if needed'
        id: create-pr
        if: needs.determine-source-branch.outputs.pr_exists != 'true'
        uses: folio-org/kitfox-github/.github/actions/create-pr@master
        with:
          repo: ${{ inputs.repo }}
          base_branch: ${{ inputs.release_branch }}
          head_branch: ${{ inputs.update_branch }}
          pr_title: "Release: Update to ${{ needs.update-platform.outputs.new_version || 'No updates' }}"
          pr_body: ${{ steps.build-pr-body.outputs.pr_body }}
          pr_labels: ${{ inputs.pr_labels }}
          pr_reviewers: ${{ inputs.pr_reviewers }}
          github_token: ${{ env.GH_TOKEN }}

      - name: 'Update existing PR if needed'
        id: update-pr
        if: needs.determine-source-branch.outputs.pr_exists == 'true'
        uses: folio-org/kitfox-github/.github/actions/update-pr@master
        with:
          repo: ${{ inputs.repo }}
          pr_number: ${{ needs.determine-source-branch.outputs.pr_number }}
          pr_title: "Release: Update to ${{ needs.update-platform.outputs.new_version }}"
          pr_body: ${{ steps.build-pr-body.outputs.pr_body }}
          pr_labels: ${{ inputs.pr_labels }}
          pr_reviewers: ${{ inputs.pr_reviewers }}
          github_token: ${{ env.GH_TOKEN }}
