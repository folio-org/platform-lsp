name: Release update (Flow)

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name'
        required: true
        type: string
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      release_branch:
        description: 'Release branch to scan (e.g., R1-2025)'
        required: true
        type: string
      update_branch:
        description: 'Update branch name for this release branch'
        required: true
        type: string
      workflow_run_number: # NOTE: Currently unused inside this workflow (kept for backward compatibility / callers)
        description: 'GitHub run number for display'
        required: true
        type: string
      dry_run:
        description: 'Perform dry run without creating PRs'
        required: false
        type: boolean
        default: false
      pr_reviewers:
        description: 'Comma-separated list of reviewers (users or teams with org/ prefix)'
        required: false
        type: string
        default: ''
      pr_labels:
        description: 'Comma-separated list of labels to add to PR'
        required: false
        type: string
        default: ''
    outputs:
      pr_created:
        description: 'Whether a PR was created or updated'
        value: ${{ jobs.manage-pr.outputs.pr_created || jobs.manage-pr.outputs.pr_updated }}
      pr_number:
        description: 'PR number if created or updated'
        value: ${{ jobs.manage-pr.outputs.pr_number }}
      pr_url:
        description: 'PR URL if created or updated'
        value: ${{ jobs.manage-pr.outputs.pr_url }}
      successful_reviewers:
        description: 'Successfully added reviewers'
        value: ${{ jobs.manage-pr.outputs.successful_reviewers }}
      failed_reviewers:
        description: 'Failed to add reviewers'
        value: ${{ jobs.manage-pr.outputs.failed_reviewers }}
      updated:
        description: 'Whether the platform descriptor was updated'
        value: ${{ jobs.update-application.outputs.updated }}
      previous_version:
        description: 'Previous platform version'
        value: ${{ jobs.update-application.outputs.previous_version }}
      new_version:
        description: 'New platform version if updated'
        value: ${{ jobs.update-application.outputs.new_version }}
      updates_cnt:
        description: 'Number of updated applications in the platform descriptor'
        value: ${{ jobs.update-application.outputs.updates_cnt }}
      updated_modules:
        description: 'List of updated Eureka components and applications'
        value: ${{ jobs.update-application.outputs.updated_modules }}
      platform_descriptor_file:
        description: 'Generated platform descriptor file path'
        value: ${{ jobs.update-application.outputs.platform_descriptor_file }}
      platform_descriptor_file_name:
        description: 'Name of updated platform descriptor file'
        value: ${{ jobs.update-application.outputs.platform_descriptor_file_name }}
      workflow_status:
        description: 'Overall workflow status'
        value: ${{ jobs.determine-source-branch.result == 'failure' && 'failure' || (jobs.update-application.result == 'failure' && 'failure' || (jobs.commit-changes.result == 'failure' && 'failure' || (jobs.manage-pr.result == 'failure' && 'failure' || 'success'))) }}
      failure_reason:
        description: 'Reason for workflow failure if any'
        value: ${{ jobs.update-application.outputs.failure_reason || (jobs.determine-source-branch.result == 'failure' && 'Failed to determine source branch' || (jobs.update-application.result == 'failure' && 'Failed to update platform modules' || (jobs.update-application.result == 'skipped' && 'Update platform job was skipped' || (jobs.commit-changes.result == 'failure' && 'Failed to commit changes to branch' || (jobs.manage-pr.result == 'failure' && 'Failed to manage pull request' || ''))))) }}

permissions:
  contents: write
  pull-requests: write
  issues: write

# Prevent overlapping runs for the same repo / release branch
concurrency:
  group: release-update-${{ inputs.repo }}-${{ inputs.release_branch }}
  cancel-in-progress: false

# Consistent shell usage & safer defaults
defaults:
  run:
    shell: bash

env:
  APP_NAME: ${{ inputs.app_name }}
  STATE_FILE: platform-descriptor.json
  GH_TOKEN: ${{ github.token }}

jobs:
  determine-source-branch:
    name: Determine Source Branch and PR Status
    runs-on: ubuntu-latest
    outputs:
      source_branch: ${{ steps.determine-branch.outputs.source_branch }}
      update_branch_exists: ${{ steps.determine-branch.outputs.update_branch_exists }}
      pr_exists: ${{ steps.check-pr.outputs.pr_exists }}
      pr_number: ${{ steps.check-pr.outputs.pr_number }}
      pr_url: ${{ steps.check-pr.outputs.pr_url }}
    steps:
      - name: Determine which branch to scan
        id: determine-branch
        env:
          REPO: ${{ inputs.repo }}
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          UPDATE_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          echo "::notice::Checking if update branch exists: $UPDATE_BRANCH"
          if gh api "repos/$REPO/branches/$UPDATE_BRANCH" >/dev/null 2>&1; then
            echo "::notice::Update branch exists, will scan: $UPDATE_BRANCH"
            echo "source_branch=$UPDATE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::Update branch does not exist, will scan: $RELEASE_BRANCH"
            echo "source_branch=$RELEASE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Check for existing PR
        id: check-pr
        if: steps.determine-branch.outputs.update_branch_exists == 'true'
        env:
          REPO: ${{ inputs.repo }}
          BASE_BRANCH: ${{ inputs.release_branch }}
          HEAD_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          echo "::notice::Checking for existing PR from $HEAD_BRANCH to $BASE_BRANCH"
          pr_json=$(gh pr list \
            --repo "$REPO" \
            --base "$BASE_BRANCH" \
            --head "$HEAD_BRANCH" \
            --json number,url \
            --jq '.[0]' || echo '{}')
          if [ "$pr_json" != "{}" ] && [ -n "$pr_json" ] && [ "$(echo "$pr_json" | jq -r '.url // ""')" != "" ]; then
            pr_number=$(echo "$pr_json" | jq -r '.number // ""')
            pr_url=$(echo "$pr_json" | jq -r '.url // ""')
            echo "::notice::Found existing PR #$pr_number: $pr_url"
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::No existing PR found"
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
            echo "pr_number=" >> "$GITHUB_OUTPUT"
            echo "pr_url=" >> "$GITHUB_OUTPUT"
          fi

  # Renamed from update-platform to update-application to align with workflow outputs
  update-application:
    name: Fetch & Update Platform Descriptor
    needs: determine-source-branch
    runs-on: ubuntu-latest
    outputs:
      updated: ${{ steps.update-descriptor.outputs.updated }}
      updated_components: ${{ steps.update-descriptor.outputs.updated_eureka_components }}
      updated_applications: ${{ steps.update-descriptor.outputs.updated_applications }}
      updated_modules: ${{ steps.update-descriptor.outputs.updated_modules }}
      previous_version: ${{ steps.update-descriptor.outputs.previous_version }}
      new_version: ${{ steps.update-descriptor.outputs.new_version }}
      updates_cnt: ${{ steps.update-descriptor.outputs.updates_cnt }}
      platform_descriptor_file: ${{ steps.update-descriptor.outputs.platform_descriptor_file }}
      platform_descriptor_file_name: ${{ steps.update-descriptor.outputs.platform_descriptor_file_name }}
      failure_reason: ${{ steps.update-descriptor.outputs.failure_reason }}
    steps:
      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ needs.determine-source-branch.outputs.source_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      # gh CLI is pre-installed on ubuntu-latest runners; retained comment for self-hosted scenarios.
      - name: Ensure gh CLI
#         if: runner.os != 'Linux' # adjust as needed for self-hosted matrices
        run: sudo apt-get update && sudo apt-get install -y gh

      - name: Fetch descriptor file
        id: fetch-descriptor
        env:
          REPO: ${{ inputs.repo }}
          SOURCE_BRANCH: ${{ needs.determine-source-branch.outputs.source_branch }}
          STATE_FILE: ${{ env.STATE_FILE }}
        run: |
          set -euo pipefail
          echo "::notice::Fetching descriptor file from branch: $SOURCE_BRANCH"
          gh api "repos/$REPO/contents/$STATE_FILE?ref=$SOURCE_BRANCH" -H "Accept: application/vnd.github.v3.raw" > "$STATE_FILE"
          if [ ! -s "$STATE_FILE" ]; then
            echo "::error::Descriptor file '$STATE_FILE' is empty or not found in branch '$SOURCE_BRANCH'"
            exit 1
          fi
          if ! jq -e 'has("eureka-components")' "$STATE_FILE" > /dev/null; then
            echo "::error::Descriptor file does not contain 'eureka-components' field"
            echo "File content:" && cat "$STATE_FILE"
            exit 1
          fi
          # Correct jq syntax for key with dash characters
          EUREKA_COMPONENTS=$(jq -c '.["eureka-components"]' "$STATE_FILE")
          {
            echo "eureka_components<<EOF"
            echo "$EUREKA_COMPONENTS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")
          {
            echo "applications<<EOF"
            echo "$APPLICATIONS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "::notice::Successfully extracted eureka-components and applications from descriptor file"

      - name: Update Eureka Components
        id: update-eureka-components
        uses: folio-org/platform-lsp/.github/actions/update-eureka-components@RANCHER-2324
        with:
          components: ${{ steps.fetch-descriptor.outputs.eureka_components }}

      - name: Update Applications
        id: update-applications
        uses: folio-org/platform-lsp/.github/actions/update-applications@RANCHER-2324
        with:
          applications: ${{ steps.fetch-descriptor.outputs.applications }}

      - name: Update Descriptor File
        id: update-descriptor
        run: |
          # set -eo pipefail
          set -x
          UPDATED_EUREKA_COMPONENTS='${{ steps.update-eureka-components.outputs.updated-components }}'
          UPDATED_APPLICATIONS='${{ steps.update-applications.outputs.updated-applications }}'
          UPDATED=false
          FAILURE_REASON=""
          
          echo "::notice::Checking for updated eureka components and applications"
          
          # Extract previous version and set file paths (outputs)
          PREVIOUS_VERSION=$(jq -r '.version // "unknown"' "$STATE_FILE")
          echo "::notice::Current platform version is $PREVIOUS_VERSION"
          {
            echo "previous_version=$PREVIOUS_VERSION"
            echo "platform_descriptor_file=$PWD/$STATE_FILE"
            echo "platform_descriptor_file_name=$STATE_FILE"
          } >> "$GITHUB_OUTPUT"
          
          CURRENT_EUREKA_COMPONENTS=$(jq -c '.["eureka-components"]' "$STATE_FILE")
          CURRENT_APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")
          
          # Check if components or applications changed
          if [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA_COMPONENTS" ] || [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPLICATIONS" ]; then
            UPDATED=true

            echo "::debug::Eureka components have been updated"
            
            # Update both components in a single jq operation
            jq --argjson components "$UPDATED_EUREKA_COMPONENTS" \
               --argjson applications "$UPDATED_APPLICATIONS" \
               '. ["eureka-components"] = $components | .applications = $applications' \
               "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"
            
            # Log what was updated
            [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA" ] && echo "::notice::Eureka components have been updated"
            [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPS" ] && echo "::notice::Applications have been updated"
          fi
          
          # Output updated components for downstream steps
          {
            echo "updated=$UPDATED"
            echo "updated_eureka_components=$UPDATED_EUREKA_COMPONENTS"
            echo "updated_applications=$UPDATED_APPLICATIONS"
          } >> "$GITHUB_OUTPUT"
          
          if [ "$UPDATED" = true ]; then

            #Diff json CURRENT_EUREKA_COMPONENTS and UPDATED_EUREKA_COMPONENTS
            diff_eureka_components=$(jq -c '.["eureka-components"]' "$STATE_FILE" | diff -u - "$UPDATED_EUREKA_COMPONENTS")
            echo "::debug::Diff eureka components: $diff_eureka_components"

            #Diff json CURRENT_APPLICATIONS and UPDATED_APPLICATIONS
            diff_applications=$(jq -c '.applications' "$STATE_FILE" | diff -u - "$UPDATED_APPLICATIONS")
            echo "::debug::Diff applications: $diff_applications"

          #   # Extract and combine updated modules in a single operation
          #   UPDATED_MODULES=$(jq -r '
          #     [
          #       (($eureka | .[] | select(.updated == true) | .name + ": " + .version) // empty),
          #       (($apps | .[] | select(.updated == true) | .name + ": " + .version) // empty)
          #     ] | join("\n")
          #   ' --argjson eureka "$UPDATED_EUREKA_COMPONENTS" --argjson apps "$UPDATED_APPLICATIONS")
            
          #   # Count updates more reliably
          #   UPDATES_CNT=$(echo "$UPDATED_MODULES" | grep -c ":" || echo "0")
            
          #   # Generate new version and update descriptor
          #   NEW_VERSION="$(date +%Y.%m.%d).${GITHUB_RUN_NUMBER:-0}"
          #   jq --arg version "$NEW_VERSION" '.version = $version' "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"
            
          #   # Output results
          #   {
          #     echo "updated_modules<<EOF"
          #     echo "$UPDATED_MODULES"
          #     echo "EOF"
          #     echo "new_version=$NEW_VERSION"
          #     echo "updates_cnt=$UPDATES_CNT"
          #   } >> "$GITHUB_OUTPUT"
            
          #   echo "::notice::Descriptor file has been updated with new versions"
            
          #   # Update step summary if available
          #   if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
          #     {
          #       echo "## Descriptor File Updates";
          #       echo "- **Previous version:** $PREVIOUS_VERSION";
          #       echo "- **New version:** $NEW_VERSION";
          #       echo "- **Total updates:** $UPDATES_CNT";
          #       echo "";
          #       echo "### Updated Modules:";
          #       echo '```';
          #       echo "$UPDATED_MODULES";
          #       echo '```';
          #     } >> "$GITHUB_STEP_SUMMARY"
          #   fi
          else
            echo "::notice::No updates needed for descriptor file"
            echo "new_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"
            echo "updates_cnt=0" >> "$GITHUB_OUTPUT"
          fi
          
          echo "failure_reason=$FAILURE_REASON" >> "$GITHUB_OUTPUT"

  #     - name: Upload Descriptor Artifact
  #       if: steps.update-descriptor.outputs.updated == 'true'
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: platform-lsp-descriptor-update
  #         path: ${{ env.STATE_FILE }}
  #         retention-days: 1

  # commit-changes:
  #   name: Commit and Push Changes
  #   needs: [determine-source-branch, update-application]
  #   if: always() && needs.update-application.outputs.updated == 'true'
  #   uses: folio-org/kitfox-github/.github/workflows/commit-application-changes.yml@RANCHER-2324
  #   with:
  #     app_name: ${{ inputs.app_name }}
  #     repo: ${{ inputs.repo }}
  #     branch: ${{ inputs.update_branch }}
  #     commit_message: "Update platform modules for release"

  # manage-pr:
  #   name: Manage Pull Request
  #   needs: [determine-source-branch, update-application, commit-changes]
  #   if: |
  #     always() && 
  #     !inputs.dry_run && 
  #     !cancelled() && 
  #     needs.update-application.result == 'success'
  #   runs-on: ubuntu-latest
  #   outputs:
  #     pr_created: ${{ steps.create-pr.outputs.pr_created == 'true' }}
  #     pr_updated: ${{ steps.update-pr.outputs.pr_updated == 'true' }}
  #     pr_number: ${{ steps.create-pr.outputs.pr_number || steps.update-pr.outputs.pr_number || needs.determine-source-branch.outputs.pr_number || '' }}
  #     pr_url: ${{ steps.create-pr.outputs.pr_url || steps.update-pr.outputs.pr_url || needs.determine-source-branch.outputs.pr_url || '' }}
  #     successful_reviewers: ${{ steps.create-pr.outputs.successful_reviewers || steps.update-pr.outputs.successful_reviewers || '' }}
  #     failed_reviewers: ${{ steps.create-pr.outputs.failed_reviewers || steps.update-pr.outputs.failed_reviewers || '' }}
  #   steps:
  #     - name: Create PR if needed
  #       id: create-pr
  #       if: |
  #         needs.determine-source-branch.outputs.pr_exists != 'true' && 
  #         (needs.update-application.outputs.updated == 'true' || 
  #          needs.determine-source-branch.outputs.update_branch_exists == 'true')
  #       uses: folio-org/kitfox-github/.github/actions/create-pr@master
  #       with:
  #         repo: ${{ inputs.repo }}
  #         base_branch: ${{ inputs.release_branch }}
  #         head_branch: ${{ inputs.update_branch }}
  #         pr_title: "Release: Update platform to ${{ needs.update-application.outputs.new_version || 'No updates' }}"
  #         pr_body: |
  #           ## Automated Platform Module Updates for Release

  #           **New Version:** ${{ needs.update-application.outputs.new_version || 'No version change' }}
  #           **Total modules updated:** ${{ needs.update-application.outputs.updates_cnt || '0' }}

  #           ### Updated Modules:
  #           ```
  #           ${{ needs.update-application.outputs.updated_modules || 'No modules updated' }}
  #           ```

  #           This PR was automatically generated by the release scan workflow.
  #         pr_labels: ${{ inputs.pr_labels }}
  #         pr_reviewers: ${{ inputs.pr_reviewers }}
  #         github_token: ${{ github.token }}

  #     - name: Update existing PR if needed
  #       id: update-pr
  #       if: |
  #         needs.determine-source-branch.outputs.pr_exists == 'true' && 
  #         needs.update-application.outputs.updated == 'true'
  #       uses: folio-org/kitfox-github/.github/actions/update-pr@master
  #       with:
  #         repo: ${{ inputs.repo }}
  #         pr_number: ${{ needs.determine-source-branch.outputs.pr_number }}
  #         pr_title: "Release: Update platform to ${{ needs.update-application.outputs.new_version }}"
  #         pr_body: |
  #           ## Automated Platform Module Updates for Release

  #           **New Version:** ${{ needs.update-application.outputs.new_version }}
  #           **Total modules updated:** ${{ needs.update-application.outputs.updates_cnt }}

  #           ### Updated Modules:
  #           ```
  #           ${{ needs.update-application.outputs.updated_modules }}
  #           ```

  #           This PR was automatically generated by the release scan workflow.
  #         pr_labels: ${{ inputs.pr_labels }}
  #         pr_reviewers: ${{ inputs.pr_reviewers }}
  #         github_token: ${{ github.token }}

