name: Release update (Flow)

on:
#   workflow_call:
  workflow_dispatch:
    inputs:
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      release_branch:
        description: 'Release branch to scan (e.g., R1-2025)'
        required: true
        type: string
      update_branch:
        description: 'Update branch name for this release branch'
        required: true
        type: string
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      dry_run:
        description: 'Perform dry run without creating PRs'
        required: false
        type: boolean
        default: false
      pr_reviewers:
        description: 'Comma-separated list of reviewers (users or teams with org/ prefix)'
        required: false
        type: string
        default: ''
      pr_labels:
        description: 'Comma-separated list of labels to add to PR'
        required: false
        type: string
        default: ''
#     outputs:
#       pr_created:
#         description: 'Whether a PR was created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_created || jobs.manage-pr.outputs.pr_updated }}
#       pr_number:
#         description: 'PR number if created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_number }}
#       pr_url:
#         description: 'PR URL if created or updated'
#         value: ${{ jobs.manage-pr.outputs.pr_url }}
#       successful_reviewers:
#         description: 'Successfully added reviewers'
#         value: ${{ jobs.manage-pr.outputs.successful_reviewers }}
#       failed_reviewers:
#         description: 'Failed to add reviewers'
#         value: ${{ jobs.manage-pr.outputs.failed_reviewers }}
#       updated:
#         description: 'Whether the platform descriptor was updated'
#         value: ${{ jobs.update-platform.outputs.updated }}
#       new_version:
#         description: 'New platform version if updated'
#         value: ${{ jobs.update-platform.outputs.new_version }}
#       updates_cnt:
#         description: 'Number of updates'
#         value: ${{ jobs.update-platform.outputs.updates_cnt }}
#       workflow_status:
#         description: 'Overall workflow status'
#         value: ${{ jobs.determine-source-branch.result == 'failure' && 'failure' || (jobs.update-platform.result == 'failure' && 'failure' || (jobs.commit-changes.result == 'failure' && 'failure' || (jobs.manage-pr.result == 'failure' && 'failure' || 'success'))) }}
#       failure_reason:
#         description: 'Reason for workflow failure if any'
#         value: ${{ jobs.determine-source-branch.result == 'failure' && 'Failed to determine source branch' || (jobs.update-platform.result == 'failure' && 'Failed to update application modules' || (jobs.update-platform.result == 'skipped' && 'Update application job was skipped' || (jobs.commit-changes.result == 'failure' && 'Failed to commit changes to branch' || (jobs.manage-pr.result == 'failure' && 'Failed to manage pull request' || '')))) }}

permissions:
  contents: write
  pull-requests: write
  issues: write

# Prevent overlapping runs for the same repo / release & update branch combination
concurrency:
  group: release-update-${{ inputs.repo }}-${{ inputs.release_branch }}-${{ inputs.update_branch }}
  cancel-in-progress: true

# Consistent shell usage & safer defaults
defaults:
  run:
    shell: bash

env:
  STATE_FILE: platform-descriptor.json
  FAR_URL: 'https://far.ci.folio.org'
  ARTIFACT_NAME: platform-lsp-update-files
  GH_TOKEN: ${{ github.token }}

jobs:
  determine-source-branch:
    name: Determine Source Branch and PR Status
    runs-on: ubuntu-latest
    outputs:
      source_branch: ${{ steps.determine-branch.outputs.source_branch }}
      update_branch_exists: ${{ steps.determine-branch.outputs.update_branch_exists }}
      pr_exists: ${{ steps.check-pr.outputs.pr_exists }}
      pr_number: ${{ steps.check-pr.outputs.pr_number }}
      pr_url: ${{ steps.check-pr.outputs.pr_url }}
    steps:
      - name: Determine which branch to scan
        id: determine-branch
        env:
          REPO: ${{ inputs.repo }}
          RELEASE_BRANCH: ${{ inputs.release_branch }}
          UPDATE_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          echo "::notice::Checking if update branch exists: $UPDATE_BRANCH"

          if gh api "repos/$REPO/branches/$UPDATE_BRANCH" >/dev/null 2>&1; then
            echo "::notice::Update branch exists, will scan: $UPDATE_BRANCH"
            echo "source_branch=$UPDATE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::Update branch does not exist, will scan: $RELEASE_BRANCH"
            echo "source_branch=$RELEASE_BRANCH" >> "$GITHUB_OUTPUT"
            echo "update_branch_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Check for existing PR
        id: check-pr
        if: steps.determine-branch.outputs.update_branch_exists == 'true'
        env:
          REPO: ${{ inputs.repo }}
          BASE_BRANCH: ${{ inputs.release_branch }}
          HEAD_BRANCH: ${{ inputs.update_branch }}
        run: |
          set -euo pipefail
          echo "::notice::Checking for existing PR from $HEAD_BRANCH to $BASE_BRANCH"

          pr_json=$(gh pr list \
            --repo "$REPO" \
            --base "$BASE_BRANCH" \
            --head "$HEAD_BRANCH" \
            --json number,url \
            --jq '.[0]' || echo '{}')

          if [ "$pr_json" != "{}" ] && [ -n "$pr_json" ] && [ "$(echo "$pr_json" | jq -r '.url // ""')" != "" ]; then
            pr_number=$(echo "$pr_json" | jq -r '.number // ""')
            pr_url=$(echo "$pr_json" | jq -r '.url // ""')
            echo "::notice::Found existing PR #$pr_number: $pr_url"
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::No existing PR found"
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
            echo "pr_number=" >> "$GITHUB_OUTPUT"
            echo "pr_url=" >> "$GITHUB_OUTPUT"
          fi

  update-platform:
    name: Read & Update Platform Descriptor
    needs: determine-source-branch
    runs-on: ubuntu-latest
    outputs:
      updated: ${{ steps.update-descriptor.outputs.updated }}
      updated_components: ${{ steps.update-descriptor.outputs.updated_eureka_components }}
      updated_applications: ${{ steps.update-descriptor.outputs.updated_applications }}
      updated_report: ${{ steps.update-descriptor.outputs.updated_report }}
      new_version: ${{ steps.update-descriptor.outputs.new_version }}
      updates_cnt: ${{ steps.update-descriptor.outputs.updates_cnt }}
      artifact_name: ${{ env.ARTIFACT_NAME }}
      failure_reason: ${{ steps.update-descriptor.outputs.failure_reason }}
      updates_markdown: ${{ steps.generate-updates-markdown.outputs.updates_markdown }}
      ui_updates_markdown: ${{ steps.generate-ui-updates-markdown.outputs.ui_updates_markdown }}
      missing_ui_markdown: ${{ steps.generate-missing-ui-report.outputs.missing_ui_markdown }}
    steps:
      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ needs.determine-source-branch.outputs.source_branch }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      # gh CLI is pre-installed on ubuntu-latest runners; retained comment for self-hosted scenarios.
      # - name: Ensure gh CLI
        # if: runner.os != 'Linux' # adjust as needed for self-hosted matrices
        # run: sudo apt-get update && sudo apt-get install -y gh

      - name: Read descriptor file
        id: read-descriptor
        env:
          REPO: ${{ inputs.repo }}
          SOURCE_BRANCH: ${{ needs.determine-source-branch.outputs.source_branch }}
          STATE_FILE: ${{ env.STATE_FILE }}
        run: |
          set -euo pipefail
          echo "::notice::Reading descriptor file from branch: $SOURCE_BRANCH"

          gh api "repos/$REPO/contents/$STATE_FILE?ref=$SOURCE_BRANCH" -H "Accept: application/vnd.github.v3.raw" > "$STATE_FILE"
          if [ ! -s "$STATE_FILE" ]; then
            echo "::error::Descriptor file '$STATE_FILE' is empty or not found in branch '$SOURCE_BRANCH'"
            exit 1
          fi

          if ! jq -e 'has("eureka-components")' "$STATE_FILE" > /dev/null; then
            echo "::error::Descriptor file does not contain 'eureka-components' field"
            echo "File content:" && cat "$STATE_FILE"
            exit 1
          fi
          EUREKA_COMPONENTS=$(jq -c '.["eureka-components"]' "$STATE_FILE")
          {
            echo "eureka_components<<EOF"
            echo "$EUREKA_COMPONENTS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          if ! jq -e 'has("applications")' "$STATE_FILE" > /dev/null; then
            echo "::error::Descriptor file does not contain 'applications' field"
            echo "File content:" && cat "$STATE_FILE"
            exit 1
          fi
          APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")
          {
            echo "applications<<EOF"
            echo "$APPLICATIONS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "::notice::Successfully extracted eureka-components and applications from descriptor file"

      - name: Update Eureka Components
        id: update-eureka-components
        uses: folio-org/platform-lsp/.github/actions/update-eureka-components@RANCHER-2324
        with:
          components: ${{ steps.read-descriptor.outputs.eureka_components }}

      - name: Update Applications
        id: update-applications
        uses: folio-org/platform-lsp/.github/actions/update-applications@RANCHER-2324
        with:
          applications: ${{ steps.read-descriptor.outputs.applications }}

      - name: Update Descriptor File
        id: update-descriptor
        env:
          UPDATED_EUREKA_COMPONENTS: ${{ steps.update-eureka-components.outputs.updated-components }}
          UPDATED_APPLICATIONS: ${{ steps.update-applications.outputs.updated-applications }}
          UPDATED: false
          FAILURE_REASON: ''
        run: |
          set -euo pipefail
          # set -x TODO remove comment after debugging
          echo "::notice::Checking for updated eureka components and applications"

          PREVIOUS_VERSION=$(jq -r '.version // "unknown"' "$STATE_FILE")
          echo "::notice::Current platform version is $PREVIOUS_VERSION"

          CURRENT_EUREKA_COMPONENTS=$(jq -c '.["eureka-components"]' "$STATE_FILE")
          CURRENT_APPLICATIONS=$(jq -c '.applications' "$STATE_FILE")

          if [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA_COMPONENTS" ] || [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPLICATIONS" ]; then
            [ "$UPDATED_EUREKA_COMPONENTS" != "$CURRENT_EUREKA_COMPONENTS" ] && echo "::notice::Eureka components have been updated"
            [ "$UPDATED_APPLICATIONS" != "$CURRENT_APPLICATIONS" ] && echo "::notice::Applications have been updated"
            UPDATED=true

            echo "::notice::Eureka components have been updated"

            if [[ "$PREVIOUS_VERSION" =~ ^(R[0-9]+-[0-9]+)\.([0-9]+)$ ]]; then
              BASE_VERSION="${BASH_REMATCH[1]}"
              PATCH_VERSION="${BASH_REMATCH[2]}"
              NEW_VERSION="${BASE_VERSION}.$((PATCH_VERSION + 1))"
            else
              FAILURE_REASON="Previous version '$PREVIOUS_VERSION' does not match expected format 'R<iteration>-<year>.<patch>'"
              echo "::error::$FAILURE_REASON"
              exit 1
            fi

            jq --arg version "$NEW_VERSION" \
              --argjson components "$UPDATED_EUREKA_COMPONENTS" \
              --argjson applications "$UPDATED_APPLICATIONS" \
              '.version = $version | .["eureka-components"] = $components | .applications = $applications' \
              "$STATE_FILE" > "${STATE_FILE}.tmp"
            mv "${STATE_FILE}.tmp" "$STATE_FILE"

            {
              echo "updated=$UPDATED"
              echo "new_version=$NEW_VERSION"
              echo "updated_eureka_components=$UPDATED_EUREKA_COMPONENTS"
              echo "updated_applications=$UPDATED_APPLICATIONS"
            } >> "$GITHUB_OUTPUT"
          fi

          if [ "$UPDATED" = true ]; then
            compare_lists() {
              local current="$1" updated="$2"

              jq -n --argjson OLD "$current" --argjson NEW "$updated" '
                def to_map: map({key:.name, value:.version}) | from_entries;
                ($OLD|to_map) as $O | ($NEW|to_map) as $N |
                [ ($O|keys[]) as $k
                  | select(($N|has($k)) and ($O[$k] != $N[$k]))
                  | { name: $k, change: { old: $O[$k], new: $N[$k] } }
                ]
              '
            }

            components=$(compare_lists "$CURRENT_EUREKA_COMPONENTS" "$UPDATED_EUREKA_COMPONENTS")

            required_applications=$(compare_lists \
              "$(jq -c '.required' <<< $CURRENT_APPLICATIONS)" \
              "$(jq -c '.required' <<< $UPDATED_APPLICATIONS)")

            optional_applications=$(compare_lists \
              "$(jq -c '.optional' <<< $CURRENT_APPLICATIONS)" \
              "$(jq -c '.optional' <<< $UPDATED_APPLICATIONS)")

            UPDATED_REPORT="$(jq -n --argjson a "$components" \
              --argjson b "$required_applications" \
              --argjson c "$optional_applications" '$a+$b+$c')"

            UPDATES_CNT=$(jq 'length' <<< "$UPDATED_REPORT")

            {
              echo "updated_report<<EOF"
              echo "$UPDATED_REPORT"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"

            echo "updates_cnt=$UPDATES_CNT" >> "$GITHUB_OUTPUT"
          fi

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            {
              echo "## Descriptor File Updates";
              if [ "$UPDATED" = true ]; then
                echo "- **Previous version:** $PREVIOUS_VERSION";
                echo "- **New version:** $NEW_VERSION";
                echo "- **Total applications/components updated:** $UPDATES_CNT";
                echo "";
                echo "### Updated Applications & Components:";
                echo '```';
                echo "$UPDATED_REPORT" | jq -r '.[] | "- " + .name + ": " + .change.old + " -> " + .change.new';
                echo '```';
              else
                echo "No updates were necessary for the descriptor file.";
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "failure_reason=$FAILURE_REASON" >> "$GITHUB_OUTPUT"

      - name: Generate Markdown Update Report
        id: generate-updates-markdown
        if: steps.update-descriptor.outputs.updated == 'true'
        env:
          UPDATED_REPORT: ${{ steps.update-descriptor.outputs.updated_report }}
          UPDATES_CNT: ${{ steps.update-descriptor.outputs.updates_cnt }}
          NEW_VERSION: ${{ steps.update-descriptor.outputs.new_version }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          if [ -z "${UPDATED_REPORT:-}" ] || [ "$(jq 'length' <<< "$UPDATED_REPORT")" -eq 0 ]; then
            markdown=$'### Application & Component Updates\n\nNo applications or eureka components were updated.'
          else
            header_line="This change updates ${UPDATES_CNT} application(s) and/or eureka component(s) for platform version ${NEW_VERSION}."
            table_rows=$(jq -r '.[] | "| " + .name + " | " + .change.old + " | " + .change.new + " |"' <<< "$UPDATED_REPORT")
            markdown=$(printf '### Application & Component Updates\n\n%s\n\n| Name | Old Version | New Version |\n| ---- | ----------- | ----------- |\n%s\n\n> Generated automatically by release-update workflow.' "$header_line" "$table_rows")
          fi

          {
            echo 'updates_markdown<<EOF'
            echo "$markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            echo "$markdown" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Fetch updated UI modules list
        id: fetch-updated-ui-modules
        if: steps.update-descriptor.outputs.updated == 'true'
        uses: folio-org/platform-lsp/.github/actions/fetch-updated-ui-modules@RANCHER-2324
        with:
          applications: ${{ steps.update-descriptor.outputs.updated_applications }}
          far-url: ${{ env.FAR_URL }}

      - name: Read package.json content
        id: read-package-json
        if: steps.update-descriptor.outputs.updated == 'true'
        env:
          REPO: ${{ inputs.repo }}
          SOURCE_BRANCH: ${{ needs.determine-source-branch.outputs.source_branch }}
        run: |
          set -euo pipefail
          echo "::notice::Reading package.json from branch: $SOURCE_BRANCH"

          # Read package.json from the repository root
          gh api "repos/$REPO/contents/package.json?ref=$SOURCE_BRANCH" -H "Accept: application/vnd.github.v3.raw" > package.json
          if [ ! -s package.json ]; then
            echo "::error::package.json file is empty or not found in branch '$SOURCE_BRANCH'"
            exit 1
          fi

          # Validate JSON format
          if ! jq empty package.json 2>/dev/null; then
            echo "::error::package.json is not valid JSON"
            cat package.json
            exit 1
          fi

          # Set package.json content as output
          PACKAGE_JSON_CONTENT=$(cat package.json | jq -c .)
          {
            echo "package_json_content<<EOF"
            echo "$PACKAGE_JSON_CONTENT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "::notice::Successfully read package.json content"

      - name: Update package.json dependencies
        id: update-package-json
        if: steps.update-descriptor.outputs.updated == 'true' && steps.fetch-updated-ui-modules.outputs.ui-modules != ''
        uses: folio-org/platform-lsp/.github/actions/update-package-json@RANCHER-2324
        with:
          package-json: ${{ steps.read-package-json.outputs.package_json_content }}
          ui-modules: ${{ steps.fetch-updated-ui-modules.outputs.ui-modules }}

      - name: Write updated package.json
        id: write-package-json
        if: steps.update-package-json.outputs.has-updates == 'true'
        run: |
          set -euo pipefail
          echo "::notice::Writing updated package.json content"

          # Write the updated package.json content to file
          echo '${{ steps.update-package-json.outputs.package-json }}' | jq . > package.json

          # Verify the file was written correctly
          if [ ! -s package.json ]; then
            echo "::error::Failed to write updated package.json"
            exit 1
          fi

          echo "::notice::Successfully updated package.json with ${{ steps.update-package-json.outputs.updated-count }} dependency changes"

          # Log updated UI modules to step summary
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            {
              echo "## Package.json Updates";
              echo "- **Updated dependencies:** ${{ steps.update-package-json.outputs.updated-count }}";
              echo "";
              echo "### Updated UI Modules:";
              echo '```';
              echo '${{ steps.update-package-json.outputs.updated-ui-report }}' | jq -r '.[] | "- " + .name + ": " + .change.old + " -> " + .change.new';
              echo '```';
              if [[ '${{ steps.update-package-json.outputs.not-found-ui-report }}' != '{}' ]]; then
                echo "";
                echo "### UI Modules Not Found in Dependencies:";
                echo '```';
                echo '${{ steps.update-package-json.outputs.not-found-ui-report }}' | jq -r 'to_entries[] | "- " + .key + ": " + .value';
                echo '```';
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Generate UI Dependency Update Report
        id: generate-ui-updates-markdown
        if: steps.update-package-json.outputs.has-updates == 'true'
        env:
          UPDATED_UI_REPORT: ${{ steps.update-package-json.outputs.updated-ui-report }}
          UPDATED_COUNT: ${{ steps.update-package-json.outputs.updated-count }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          if [ -z "${UPDATED_UI_REPORT:-}" ] || [ "${UPDATED_UI_REPORT}" = '[]' ] || [ "$(jq 'length' <<< "$UPDATED_UI_REPORT")" -eq 0 ]; then
            markdown=$'### UI Dependency Updates\n\nNo UI dependencies were updated.'
          else
            header_line="This change updates ${UPDATED_COUNT} UI dependency(ies) in package.json."
            table_rows=$(jq -r '.[] | "| " + .name + " | " + .change.old + " | " + .change.new + " |"' <<< "$UPDATED_UI_REPORT")
            markdown=$(printf '### UI Dependency Updates\n\n%s\n\n| Dependency | Old Version | New Version |\n| ---------- | ----------- | ----------- |\n%s\n\n> Generated automatically by release-update workflow.' "$header_line" "$table_rows")
          fi

          {
            echo 'ui_updates_markdown<<EOF'
            echo "$markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            echo "$markdown" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Generate Missing UI Dependencies Report
        id: generate-missing-ui-report
        if: steps.update-package-json.outputs.not-found-ui-report != '{}' && steps.update-package-json.outputs.not-found-ui-report != ''
        env:
          NOT_FOUND_UI_REPORT: ${{ steps.update-package-json.outputs.not-found-ui-report }}
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          if [ -z "${NOT_FOUND_UI_REPORT:-}" ] || [ "${NOT_FOUND_UI_REPORT}" = '{}' ]; then
            markdown=$'### Missing UI Dependencies\n\nNo missing UI dependencies detected.'
          else
            # Count missing items (object entries)
            missing_cnt=$(jq 'length' <<< "$NOT_FOUND_UI_REPORT" || echo 0)
            header_line="${missing_cnt} UI module(s) referenced by application descriptors were NOT found in package.json and were not updated."
            table_rows=$(jq -r 'to_entries[] | "| " + .key + " | " + (.value|tostring) + " |"' <<< "$NOT_FOUND_UI_REPORT")
            markdown=$(printf '### Missing UI Dependencies\n\n%s\n\n| Module | Referenced Version |\n| ------ | ------------------ |\n%s\n\n> Review package.json to add these dependencies if they are required.' "$header_line" "$table_rows")
          fi

          {
            echo 'missing_ui_markdown<<EOF'
            echo "$markdown"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            echo "$markdown" >> "$GITHUB_STEP_SUMMARY"
          fi
      - name: Upload Descriptor Artifact
        if: steps.update-descriptor.outputs.updated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.ARTIFACT_NAME }}"
          path: |
            ${{ env.STATE_FILE }}
            package.json
          retention-days: 1
  
  commit-changes:
    name: Commit and Push Changes
    needs: [determine-source-branch, update-platform]
    if: needs.update-platform.outputs.updated == 'true'
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@master
    with:
      repo: ${{ inputs.repo }}
      branch: ${{ inputs.update_branch }}
      artifact_name: ${{ needs.update-platform.outputs.artifact_name }}
      commit_message: |
        Update platform to ${{ needs.update-platform.outputs.new_version }}.

        **Total applications/components updated:** ${{ needs.update-platform.outputs.updates_cnt || '0' }}
        ${{ needs.update-platform.outputs.updates_markdown }}
      dry_run: ${{ inputs.dry_run }}
      use_github_app: true
      source_branch: ${{ needs.determine-source-branch.outputs.source_branch }}
    secrets: inherit

  manage-pr:
    name: Manage Pull Request
    needs: [determine-source-branch, update-platform, commit-changes]
    if: |
      always() &&
      !inputs.dry_run &&
      !cancelled() &&
      needs.update-platform.result == 'success' &&
      (
        needs.update-platform.outputs.updated == 'true' ||
        (
          needs.determine-source-branch.outputs.pr_exists != 'true' &&
          needs.determine-source-branch.outputs.update_branch_exists == 'true'
        )
      )
    runs-on: ubuntu-latest
    outputs:
      pr_created: ${{ steps.create-pr.outputs.pr_created == 'true' }}
      pr_updated: ${{ steps.update-pr.outputs.pr_updated == 'true' }}
      pr_number: ${{ steps.create-pr.outputs.pr_number || steps.update-pr.outputs.pr_number || needs.determine-source-branch.outputs.pr_number || '' }}
      pr_url: ${{ steps.create-pr.outputs.pr_url || steps.update-pr.outputs.pr_url || needs.determine-source-branch.outputs.pr_url || '' }}
      successful_reviewers: ${{ steps.create-pr.outputs.successful_reviewers || steps.update-pr.outputs.successful_reviewers || '' }}
      failed_reviewers: ${{ steps.create-pr.outputs.failed_reviewers || steps.update-pr.outputs.failed_reviewers || '' }}
    steps:
      # - name: Compare Application Versions
      #   id: compare
      #   uses: folio-org/kitfox-github/.github/actions/compare-state-files@master
      #   with:
      #     repo: ${{ inputs.repo }}
      #     base-source-type: 'branch'
      #     base-source: ${{ inputs.release_branch }}
      #     head-source-type: 'branch'
      #     head-source: ${{ inputs.update_branch }}
      #     state-file: 'application-descriptor.json'
      #     github-token: ${{ github.token }}

      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ inputs.app_name }}

      - name: Create PR if needed
        id: create-pr
        if: |
          needs.determine-source-branch.outputs.pr_exists != 'true' &&
          (needs.update-platform.outputs.updated == 'true' ||
           needs.determine-source-branch.outputs.update_branch_exists == 'true')
        uses: folio-org/kitfox-github/.github/actions/create-pr@master
        with:
          repo: ${{ inputs.repo }}
          base_branch: ${{ inputs.release_branch }}
          head_branch: ${{ inputs.update_branch }}
          pr_title: "Release: Update to ${{ needs.update-platform.outputs.new_version || 'No updates' }}"
          pr_body: |
            ## Automated Application & Component Updates for Release

            **New Version:** ${{ needs.update-platform.outputs.new_version || 'No version change' }}
            **Total applications/components updated:** ${{ needs.update-platform.outputs.updates_cnt || '0' }}

            ${{ needs.update-platform.outputs.updates_markdown || '### Application & Component Updates\n\nNo applications or eureka components were updated.' }}

            ${{ needs.update-platform.outputs.ui_updates_markdown || '### UI Dependency Updates\n\nNo UI dependencies were updated.' }}

            ${{ needs.update-platform.outputs.missing_ui_markdown || '### Missing UI Dependencies\n\nNo missing UI dependencies detected.' }}

            This PR was automatically generated by the release scan workflow.
          pr_labels: ${{ inputs.pr_labels }}
          pr_reviewers: ${{ inputs.pr_reviewers }}
          github_token: ${{ steps.app-token.outputs.token || github.token }}

      - name: Update existing PR if needed
        id: update-pr
        if: |
          needs.determine-source-branch.outputs.pr_exists == 'true' &&
          needs.update-platform.outputs.updated == 'true'
        uses: folio-org/kitfox-github/.github/actions/update-pr@master
        with:
          repo: ${{ inputs.repo }}
          pr_number: ${{ needs.determine-source-branch.outputs.pr_number }}
          pr_title: "Release: Update to ${{ needs.update-platform.outputs.new_version }}"
          pr_body: |
            ## Automated Application & Component Updates for Release

            **New Version:** ${{ needs.update-platform.outputs.new_version }}
            **Total applications/components updated:** ${{ needs.update-platform.outputs.updates_cnt }}

            ${{ needs.update-platform.outputs.updates_markdown || '### Application & Component Updates\n\nNo applications or eureka components were updated.' }}

            ${{ needs.update-platform.outputs.ui_updates_markdown || '### UI Dependency Updates\n\nNo UI dependencies were updated.' }}

            ${{ needs.update-platform.outputs.missing_ui_markdown || '### Missing UI Dependencies\n\nNo missing UI dependencies detected.' }}

            This PR was automatically generated by the release scan workflow.
          pr_labels: ${{ inputs.pr_labels }}
          pr_reviewers: ${{ inputs.pr_reviewers }}
          github_token: ${{ steps.app-token.outputs.token || github.token }}
