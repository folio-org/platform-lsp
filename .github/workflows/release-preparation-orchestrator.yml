name: Release preparation orchestrator

on:
  workflow_dispatch:
    inputs:
      previous_release_branch:
        description: 'Previous release branch (e.g., R1-2024)'
        required: true
        type: string
      new_release_branch:
        description: 'New release branch (e.g., R2-2024)'
        required: true
        type: string
      new_applications:
        description: 'Comma, space, or newline-separated list of new applications to include in this release (e.g., app-new-feature,app-another)'
        required: false
        type: string
        default: ''
      use_snapshot_fallback:
        description: 'Use app snapshot branch if previous release branch not found'
        required: false
        type: boolean
        default: false
      use_snapshot_version:
        description: 'Use app snapshot version as a base version'
        required: false
        type: boolean
        default: false
      branch_name:
        description: 'Display name for the release branch (e.g., "FOLIO Sunflower Release")'
        required: false
        type: string
        default: ''
      branch_description:
        description: 'Description for the release branch'
        required: false
        type: string
        default: 'FOLIO LSP (Library Services Platform) is a set of microservices and applications that provide a complete library management system.'
      need_pr:
        description: 'Require PR for version updates on this branch'
        required: false
        type: boolean
        default: true
      prerelease_mode:
        description: 'PreRelease mode for version updates ("false", "true", or "only")'
        required: false
        type: string
        default: 'false'
      dry_run:
        description: 'Perform dry run without making changes'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ inputs.new_release_branch }}
  cancel-in-progress: false

env:
  PLATFORM_TEMPLATE_FILE: 'platform.template.json'
  UPDATE_CONFIG_FILE: '.github/update-config.yml'
  UPDATE_CONFIG_TEMPLATE_PATH: '.github/templates/update-config.yml.template'

jobs:
  validate-actor:
    name: Validate Actor
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.validate-actor.outputs.authorized }}
    steps:
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}

      - name: Validate Actor
        id: validate-actor
        uses: folio-org/kitfox-github/.github/actions/validate-team-membership@master
        with:
          username: ${{ github.actor }}
          organization: 'folio-org'
          team: 'kitfox'
          token: ${{ steps.app-token.outputs.token }}

  approve-run:
    name: Approve Run
    needs: validate-actor
    runs-on: ubuntu-latest
    environment: Eureka CI
    if: needs.validate-actor.outputs.authorized == 'false'
    steps:
      - name: Run approvement
        run: |
          echo "::notice::This run was approved by $(
            gh api \
              /repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/approvals \
              --jq \
                '.[]
                | select(.environments[]?.name == "Eureka CI")
                | .user.login')"

  initial-check:
    name: Initial Check
    runs-on: ubuntu-latest
    needs: [ validate-actor, approve-run ]
    if: always() && (needs.validate-actor.outputs.authorized == 'true' || needs.approve-run.result == 'success')
    outputs:
      applications: ${{ steps.merge-applications.outputs.applications }}
      application_count: ${{ steps.merge-applications.outputs.application_count }}
      default_branch: ${{ steps.detect-default-branch.outputs.default_branch }}
    env:
      PREV_BRANCH: ${{ inputs.previous_release_branch }}
      NEW_BRANCH: ${{ inputs.new_release_branch }}
      FILE: "platform-descriptor.json"

    steps:
      - name: Input parameters
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call'
        env:
          INPUT_PARAMS: ${{ toJSON(github.event.inputs) }}
        run: |
          set -eo pipefail

          echo "::notice::Input parameters"
          echo ""
          echo "$INPUT_PARAMS" | jq '.'
          echo ""

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "::notice::This was a dry run - no actual changes were made"
            echo "::notice::Set dry_run=false to apply changes"
          fi

      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify Branches
        id: verify-branches
        run: |
          set -eo pipefail

          if ! git ls-remote --exit-code --heads origin "$PREV_BRANCH" >/dev/null 2>&1; then
            echo "::error::Missing branch. Previous release branch '$PREV_BRANCH' not found"
            exit 1
          fi

          if git ls-remote --exit-code --heads origin "$NEW_BRANCH" >/dev/null 2>&1; then
            echo "::error::New release branch '$NEW_BRANCH' already exists"
            exit 1
          fi

          echo "::notice::Previous release branch '$PREV_BRANCH' exists and new release branch '$NEW_BRANCH' does not exist"

      - name: Checkout Previous Release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.previous_release_branch }}
          fetch-depth: 0

      - name: Extract Existing Applications
        id: extract-applications
        run: |
          set -eo pipefail

          if [ ! -f "$FILE" ]; then
            echo "::error::$FILE not found in $PREV_BRANCH"
            exit 1
          fi

          existing_apps=$(jq -c '[.applications.required[]?, .applications.optional[]? | select(.name | startswith("app-")) | .name]' "$FILE")
          existing_count=$(jq -r 'length' <<<"$existing_apps")

          if ! [[ "$existing_count" -gt 0 ]]; then
            echo "::error::Could not find any applications in $FILE, or the file is malformed."
            exit 1
          fi

          echo "::notice::Descriptor verified. $FILE found in $PREV_BRANCH with $existing_count existing app(s)"
          jq -r '.[]' <<<"$existing_apps" | sed 's/^/  - /'
          echo "applications=$existing_apps" >> "$GITHUB_OUTPUT"
          echo "application_count=$existing_count" >> "$GITHUB_OUTPUT"

      - name: Parse New Applications
        id: parse-new-applications
        env:
          NEW_APPS: ${{ inputs.new_applications }}
        run: |
          set -eo pipefail
          IFS=$'\n\t'

          new_apps_json=$(jq -Rn -c --arg input "${NEW_APPS:-}" '
              $input
              | gsub("[,[:space:]]+"; "\n")   # turn every run of commas/white-space into a newline
              | split("\n")                   # split on those new-lines
              | map(select(length>0))         # drop blanks
              | unique                        # dedupe
              | sort                          # stable order
            ')

          new_count=$(jq 'length' <<<"$new_apps_json")

          echo "::notice::Found $new_count new application(s)"
          jq -r '.[]' <<<"$new_apps_json" | sed 's/^/  - /'
          echo "applications=$new_apps_json" >> "$GITHUB_OUTPUT"
          echo "application_count=$new_count" >> "$GITHUB_OUTPUT"

      - name: Merge Applications
        id: merge-applications
        env:
          EXISTING_APPS: ${{ steps.extract-applications.outputs.applications }}
          NEW_APPS:      ${{ steps.parse-new-applications.outputs.applications }}
        run: |
          set -eo pipefail
          IFS=$'\n\t'

          merged_apps=$(jq -c -n --argjson existing "$EXISTING_APPS" --argjson new "$NEW_APPS" '
              ( $existing + $new )                # concatenate
              | unique                            # remove dupes
              | sort                              # deterministic order
          ')

          total_count=$(jq 'length' <<<"$merged_apps")

          if (( total_count == 0 )); then
            echo "::error::No applications to process. After merging, list is empty."
            exit 1
          fi

          echo "::notice::Applications merged. $total_count total application(s)"
          echo "::group::Complete application list"
          jq -r '.[]' <<<"$merged_apps" | sed 's/^/  - /'
          echo "::endgroup::"

          echo "applications=$merged_apps"      >> "$GITHUB_OUTPUT"
          echo "application_count=$total_count" >> "$GITHUB_OUTPUT"

      - name: Detect Default Branch
        id: detect-default-branch
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eo pipefail

          default_branch=$(gh api repos/${{ github.repository }} --jq .default_branch)
          if [ -z "$default_branch" ]; then
            echo "::error::Could not determine default branch for ${{ github.repository }}"
            exit 1
          fi

          echo "::notice::Default branch is: $default_branch"
          echo "default_branch=$default_branch" >> "$GITHUB_OUTPUT"

  check-applications:
    name: Check ${{ matrix.application }} Application
    needs: initial-check
    if: always() && needs.initial-check.result == 'success'
    strategy:
      matrix:
        application: ${{ fromJson(needs.initial-check.outputs.applications) }}
      fail-fast: false
      max-parallel: 10
    uses: folio-org/kitfox-github/.github/workflows/release-preparation-flow.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      app_name: ${{ matrix.application }}
      repo: folio-org/${{ matrix.application }}
      previous_release_branch: ${{ inputs.previous_release_branch }}
      new_release_branch: ${{ inputs.new_release_branch }}
      use_snapshot_fallback: ${{ inputs.use_snapshot_fallback }}
      use_snapshot_version: ${{ inputs.use_snapshot_version }}
      dry_run: true
    secrets: inherit

  update-applications:
    name: Update ${{ matrix.application }} Application
    needs: [initial-check, check-applications]
    if: always() && needs.check-applications.result == 'success' && inputs.dry_run != true
    strategy:
      matrix:
        application: ${{ fromJson(needs.initial-check.outputs.applications) }}
      fail-fast: false
      max-parallel: 10
    uses: folio-org/kitfox-github/.github/workflows/release-preparation-flow.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      app_name: ${{ matrix.application }}
      repo: folio-org/${{ matrix.application }}
      previous_release_branch: ${{ inputs.previous_release_branch }}
      new_release_branch: ${{ inputs.new_release_branch }}
      use_snapshot_fallback: ${{ inputs.use_snapshot_fallback }}
      use_snapshot_version: ${{ inputs.use_snapshot_version }}
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  collect-results:
    name: Collect Application Results
    needs: [initial-check, check-applications, update-applications]
    runs-on: ubuntu-latest
    if: always() && needs.check-applications.result != 'skipped'
    outputs:
      failed_apps: ${{ steps.gather-failures.outputs.failed_apps }}
      successful_apps: ${{ steps.gather-failures.outputs.successful_apps }}
      success_count: ${{ steps.gather-failures.outputs.success_count }}
      failure_count: ${{ steps.gather-failures.outputs.failure_count }}
      prepared_apps: ${{ steps.gather-failures.outputs.prepared_apps }}
    steps:
      - name: Download All Application Results
        uses: actions/download-artifact@v4
        with:
          pattern: "result-*"
          path: /tmp/all-results
          merge-multiple: true

      - name: Gather Application Results
        id: gather-failures
        run: |
          set -eo pipefail

          echo "::notice::Analyzing application results"

          all=$(jq -s '.' /tmp/all-results/*.json)

          success_count=$(jq '[.[] | select(.status=="success")] | length' <<<"$all")
          failure_count=$(jq '[.[] | select(.status!="success")] | length' <<<"$all")
          failed_apps=$(jq -r '[.[] | select(.status!="success") | .application] | join("\n")' <<<"$all")
          successful_apps=$(jq -r '[.[] | select(.status=="success") | .application] | join("\n")' <<<"$all")

          prepared_apps=$(jq -r --arg base "${GITHUB_SERVER_URL}" --arg branch "${{ inputs.new_release_branch }}" '
            [.[]
              | select(.status=="success")
              | "<\($base)/folio-org/\(.application)/tree/\($branch)|\(.application) (\(.version))>"
            ]
            | join("\n")
          ' <<<"$all")

          echo "::notice::Results Summary - Success: $success_count, Failures: $failure_count"

          echo "success_count=$success_count" >> "$GITHUB_OUTPUT"
          echo "failure_count=$failure_count" >> "$GITHUB_OUTPUT"
          {
            echo "prepared_apps<<EOF"
            printf '%s\n' "$prepared_apps"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "successful_apps<<EOF"
            printf '%s\n' "$successful_apps"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "failed_apps<<EOF"
            printf '%s\n' "$failed_apps"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"          

  prepare-platform:
    name: Prepare Platform Template
    needs:
      - initial-check
      - check-applications
      - update-applications
      - collect-results
    runs-on: ubuntu-latest
    if: always() && needs.check-applications.result == 'success' && needs.update-applications.result != 'failed' && needs.collect-results.result == 'success'
    outputs:
      platform_version: ${{ steps.update-platform-template.outputs.platform_version }}
    steps:
      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.previous_release_branch }}
          fetch-depth: 0

      - name: Download Application Results
        uses: actions/download-artifact@v4
        with:
          pattern: "result-*"
          path: /tmp/app-results
          merge-multiple: true

      - name: Update Platform Template
        id: update-platform-template
        run: |
          set -eo pipefail

          if [ ! -f "$PLATFORM_TEMPLATE_FILE" ]; then
            echo "::error::$PLATFORM_TEMPLATE_FILE not found"
            exit 1
          fi

          echo "::notice::Dumping downloaded application result files"
          echo "::group::Application result artifacts"
          for f in /tmp/app-results/*.json; do
            echo "‚îÄ‚îÄ‚îÄ $f ‚îÄ‚îÄ‚îÄ"
            cat "$f"
          done
          echo "::endgroup::"

          echo "::group::Current platform template"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          tmp=$(mktemp)
          results_file=$(mktemp)

          echo "::notice::Let's combine all application results into a single flat array"
          jq -s '.' /tmp/app-results/*.json > "$results_file"   # Combine all JSON files into a single array

          echo "::group::Combined application results"
          cat "$results_file"
          echo "::endgroup::"

          echo "::notice::Updating application versions with ^VERSION constraints and preRelease flags"
          jq --slurpfile results "$results_file" '
            reduce $results[0][] as $r (
              .;
              if ([.applications.required[]?, .applications.optional[]? | .name] | any(. == $r.application)) then
                .applications.required |= map(
                  if .name == $r.application then .version = ("^" + $r.version) | .preRelease = "false" else . end
                )
                | .applications.optional |= map(
                  if .name == $r.application then .version = ("^" + $r.version) | .preRelease = "false" else . end
                )
              else
                .applications.optional += [{
                  name: $r.application,
                  version: ("^" + $r.version),
                  preRelease: "false"
                }]
              end
            )
          ' "$PLATFORM_TEMPLATE_FILE" > "$tmp"

          rm "$results_file" && mv "$tmp" "$PLATFORM_TEMPLATE_FILE"

          echo "::group::Updated application versions"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          echo "::notice::Updating platform version and eureka-components with preRelease flags"
          tmp2=$(mktemp)
          jq --arg newVer "${{ inputs.new_release_branch }}" '
            .version = $newVer                                                            #update platform version to release branch
            | ."eureka-components" |= map(.version = "^VERSION" | .preRelease = "false")  #placeholder all eureka-component versions with preRelease
          ' "$PLATFORM_TEMPLATE_FILE" > "$tmp2" \
          && mv "$tmp2" "$PLATFORM_TEMPLATE_FILE"

          echo "::group::Updated platform template"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          echo "platform_version=${{ inputs.new_release_branch }}" >> "$GITHUB_OUTPUT"

      - name: Upload Platform Template
        uses: actions/upload-artifact@v4
        with:
          name: platform-release-files
          path: ${{ env.PLATFORM_TEMPLATE_FILE }}
          retention-days: 1

  update-platform-config:
    name: Update Platform Configuration
    needs: [initial-check, prepare-platform]
    if: always() && needs.prepare-platform.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      config_updated: ${{ steps.update-config.outputs.updated }}

    steps:
      - name: Checkout Default Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.initial-check.outputs.default_branch }}
          fetch-depth: 1

      - name: Get or Create Update Config
        id: update-config
        env:
          NEW_BRANCH: ${{ inputs.new_release_branch }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          BRANCH_DESCRIPTION: ${{ inputs.branch_description }}
          NEED_PR: ${{ inputs.need_pr }}
          PRERELEASE_MODE: ${{ inputs.prerelease_mode }}
        run: |
          set -eo pipefail

          if [ -f "$UPDATE_CONFIG_FILE" ]; then
            echo "::notice::$UPDATE_CONFIG_FILE exists"
          else
            echo "::notice::$UPDATE_CONFIG_FILE not found, creating from template"

            git clone --depth 1 https://github.com/folio-org/platform-lsp.git /tmp/platform-lsp -b RANCHER-2572-test #TODO: Remove specific branch

            template_path="/tmp/platform-lsp/$UPDATE_CONFIG_TEMPLATE_PATH"
            if [ ! -f "$template_path" ]; then
              echo "::error::Template not found at $template_path"
              exit 1
            fi

            mkdir -p "$(dirname "$UPDATE_CONFIG_FILE")"
            cp "$template_path" "$UPDATE_CONFIG_FILE"
          fi

          if yq eval ".branches[] | select(. == \"$NEW_BRANCH\" or .\"$NEW_BRANCH\")" "$UPDATE_CONFIG_FILE" | grep -q "$NEW_BRANCH"; then
            echo "::notice::Branch $NEW_BRANCH already in config, no update needed"
            echo "updated=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          branch_config=$(jq -n \
            --arg branch "$NEW_BRANCH" \
            --arg name "$BRANCH_NAME" \
            --arg desc "$BRANCH_DESCRIPTION" \
            --argjson need_pr "$NEED_PR" \
            --arg prerelease "$PRERELEASE_MODE" \
            '{
              ($branch): {
                enabled: true,
                need_pr: $need_pr,
                preRelease: $prerelease
              }
              | (if $name != "" then . + {name: $name} else . end)
              | (if $desc != "" then . + {description: $desc} else . end)
            }')

          echo "::notice::Adding branch configuration:"
          echo "$branch_config" | jq .

          yq eval ".branches += [$branch_config]" -i "$UPDATE_CONFIG_FILE"

          echo "::group::Updated config"
          cat "$UPDATE_CONFIG_FILE"
          echo "::endgroup::"

          echo "updated=true" >> "$GITHUB_OUTPUT"

      - name: Prepare Config for Upload
        if: steps.update-config.outputs.updated == 'true'
        run: |
          set -eo pipefail

          echo "::notice::Preparing config file for artifact upload"
          artifact_dir="/tmp/config-artifact"
          mkdir -p "$artifact_dir/$(dirname "$UPDATE_CONFIG_FILE")"
          cp "$UPDATE_CONFIG_FILE" "$artifact_dir/$UPDATE_CONFIG_FILE"

          echo "::group::Artifact structure"
          find "$artifact_dir" -type f
          echo "::endgroup::"

      - name: Upload Config File
        if: steps.update-config.outputs.updated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: platform-config-file
          path: /tmp/config-artifact/
          include-hidden-files: true
          retention-days: 1

  commit-platform-changes:
    name: Commit Platform Release Branch
    needs: [initial-check, prepare-platform]
    if: always() && needs.prepare-platform.result == 'success'
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      repo: ${{ github.repository }}
      branch: ${{ inputs.new_release_branch }}
      source_branch: ${{ inputs.previous_release_branch }}
      artifact_name: platform-release-files
      commit_message: |
        Prepare platform for release. Initial commit.

        Previous release: ${{ inputs.previous_release_branch }}
        New release: ${{ inputs.new_release_branch }}
        Applications processed: ${{ needs.initial-check.outputs.application_count }}

        Application versions set to ^VERSION constraints.
        Eureka component versions set to ^VERSION placeholder.
      deleted_files: |
        platform-descriptor.json
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  commit-platform-config:
    name: Commit Platform Config to Default Branch
    needs: [initial-check, update-platform-config, commit-platform-changes]
    if: always() && needs.update-platform-config.result == 'success'
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      repo: ${{ github.repository }}
      branch: ${{ needs.initial-check.outputs.default_branch }}
      artifact_name: platform-config-file
      commit_message: |
        Add ${{ inputs.new_release_branch }} to platform update configuration

        Automatically added by release preparation workflow.
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  slack_notification:
    name: Slack Notification
    runs-on: ubuntu-latest
    needs:
      - initial-check
      - check-applications
      - update-applications
      - collect-results
      - prepare-platform
      - commit-platform-changes
      - update-platform-config
      - commit-platform-config
    if: always() && inputs.dry_run == false
    outputs:
      notification_outcome: ${{ steps.send-success.outcome || steps.send-failure.outcome }}
    env:
      IS_SUCCESS: >-
        ${{
            needs.check-applications.result == 'failure' && 'false' ||
            needs.update-applications.result == 'failure' && 'false' ||
            needs.prepare-platform.result == 'failure' && 'false' ||
            needs.commit-platform-changes.result == 'failure' && 'false' ||
            needs.update-platform-config.result == 'failure' && 'false' ||
            needs.commit-platform-config.result == 'failure' && 'false' ||
            needs.collect-results.result == 'failure' && 'false' ||
            'true'
        }}
      FAILURE_REASON: >-
        ${{
            needs.check-applications.result == 'failure' && 'Application validation failed' ||
            needs.update-applications.result == 'failure' && 'Application update failed' ||
            needs.prepare-platform.result == 'failure' && 'Platform template preparation failed' ||
            needs.update-platform-config.result == 'failure' && 'Platform config update failed' ||
            needs.collect-results.result == 'failure' && 'Application result collection failed' ||
            needs.commit-platform-changes.result == 'failure' && 'Platform branch commit failed' ||
            needs.commit-platform-config.result == 'failure' && 'Platform config commit failed' ||
            'Unknown failure'
        }}
      IS_FAILED_APPS: >-
        ${{ 
            (needs.check-applications.result == 'failure' || needs.update-applications.result == 'failure') && 
            'true' || 'false'
        }}
    steps:
      - name: Send SUCCESS Slack Notification
        id: send-success
        if: env.IS_SUCCESS == 'true'
        env:
          TITLE_TEXT: "Platform Release Preparation SUCCESS"
          TITLE_BLOCK: |
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Platform Release Preparation SUCCESS <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>*"
              }
            }
          SUCCESS_ATTACHMENT: |
            {
              "color": "good",
              "fields": [
                {
                  "title": "New Release",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }}|${{ inputs.new_release_branch }}>",
                  "short": true
                },
                {
                  "title": "Previous Release",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }}|${{ inputs.previous_release_branch }}>",
                  "short": true
                },
                {
                  "title": "Applications Processed",
                  "value": "${{ needs.initial-check.outputs.application_count }}",
                  "short": true
                },
                {
                  "title": "Commit",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/commit/${{ needs.commit-platform-changes.outputs.commit_sha }}|${{ needs.commit-platform-changes.outputs.commit_sha }}>",
                  "short": true
                }
              ]
            }
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.EUREKA_CI_SLACK_BOT_TOKEN }}
          errors: true
          payload: |
            {
              "channel": "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}",
              "text": "${{ env.TITLE_TEXT }}",
              "blocks": [
                ${{ env.TITLE_BLOCK }}
              ],
              "attachments": [
                ${{ env.SUCCESS_ATTACHMENT }},
                {
                  "color": "good",
                  "mrkdwn_in": ["text"],
                  "text": ${{ toJSON(needs.collect-results.outputs.prepared_apps) }},
                  "footer": "Eureka CI/CD"
                }
              ]
            }

      - name: Send FAILED Slack Notification
        id: send-failure
        if: env.IS_SUCCESS == 'false'
        env:
          TITLE_TEXT: "Platform Release Preparation FAILED"
          TITLE_BLOCK: |
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*Platform Release Preparation FAILED <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>*"
              }
            }
          FAILURE_ATTACHMENT: |
            {
              "color": "danger",
              "fields": [
                {
                  "title": "New Release",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }}|${{ inputs.new_release_branch }}>",
                  "short": true
                },
                {
                  "title": "Previous Release",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }}|${{ inputs.previous_release_branch }}>",
                  "short": true
                },
                {
                  "title": "Applications Successfully Processed",
                  "value": "${{ needs.collect-results.outputs.success_count }}",
                  "short": true
                },
                {
                  "title": "Applications Failed",
                  "value": "${{ needs.collect-results.outputs.failure_count }}",
                  "short": true
                },
                {
                  "title": "Failure Reason",
                  "value": "${{ env.FAILURE_REASON }}",
                  "short": false
                }
              ],
              ${{ env.IS_FAILED_APPS == 'false' && '"footer": "Eureka CI/CD"' || '' }}
            }
          FAILED_APPS: |
            {
              "color": "danger",
              "mrkdwn_in": ["text"],
              "text": ${{ toJSON(needs.collect-results.outputs.failed_apps) }},
              "footer": "Eureka CI/CD"
            }
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.EUREKA_CI_SLACK_BOT_TOKEN }}
          errors: true
          payload: |
            {
              "channel": "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}",
              "text": "${{ env.TITLE_TEXT }}",
              "blocks": [
                ${{ env.TITLE_BLOCK }}
              ],
              "attachments": [
                ${{ env.FAILURE_ATTACHMENT }},
                ${{ env.IS_FAILED_APPS == 'true' && env.FAILED_APPS || '' }}
              ]
            }

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs:
      - initial-check
      - check-applications
      - update-applications
      - collect-results
      - prepare-platform
      - commit-platform-changes
      - commit-platform-config
      - slack_notification
    if: always()
    steps:
      - name: Generate Workflow Summary
        env:
          TOTAL_APPS: ${{ needs.initial-check.outputs.application_count }}
          SUCCESS_COUNT: ${{ needs.collect-results.outputs.success_count || '0' }}
          FAILURE_COUNT: ${{ needs.collect-results.outputs.failure_count || '0' }}
          FAILED_APPS: ${{ needs.collect-results.outputs.failed_apps }}
          SUCCESSFUL_APPS: ${{ needs.collect-results.outputs.successful_apps }}
          PREPARED_APPS: ${{ needs.collect-results.outputs.prepared_apps }}
          PLATFORM_VERSION: ${{ needs.prepare-platform.outputs.platform_version }}
          PLATFORM_UPDATE_RESULT: ${{ needs.prepare-platform.result }}
          PLATFORM_COMMIT_RESULT: ${{ needs.commit-platform-changes.result }}
          PLATFORM_COMMIT_SHA: ${{ needs.commit-platform-changes.outputs.commit_sha }}
          CONFIG_UPDATED: ${{ needs.update-platform-config.outputs.config_updated }}
          CONFIG_UPDATE_RESULT: ${{ needs.update-platform-config.result }}
          CONFIG_COMMIT_RESULT: ${{ needs.commit-platform-config.result }}
          CONFIG_COMMIT_SHA: ${{ needs.commit-platform-config.outputs.commit_sha }}
          SLACK_OUTCOME: ${{ needs.slack_notification.outputs.notification_outcome }}
          INITIAL_RESULT: ${{ needs.initial-check.result }}
          CHECK_RESULT: ${{ needs.check-applications.result }}
          UPDATE_RESULT: ${{ needs.update-applications.result }}
          COLLECT_RESULT: ${{ needs.collect-results.result }}
        run: |
          summary="$GITHUB_STEP_SUMMARY"

          section() { echo -e "\n## $1" >> "$summary"; }
          line()    { echo "$@" >> "$summary"; }

          section "üöÄ Platform Release Preparation Summary"

          print_stats() {
            line "- **Previous Release**: [\`${{ inputs.previous_release_branch }}\`](${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }})"
            line "- **New Release**: [\`${{ inputs.new_release_branch }}\`](${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }})"
            line "- **Total Applications**: $TOTAL_APPS"
            [[ -n "$SUCCESS_COUNT" ]] && line "- **Successfully Prepared**: $SUCCESS_COUNT"
            [[ -n "$FAILURE_COUNT" ]] && line "- **Failed Applications**: $FAILURE_COUNT"
            line "- **Triggered by**: ${{ github.actor }}"
            line "- **Run Number**: ${{ github.run_number }}"
            line ""
          }

          print_list() {
            [[ -z "$1" ]] && return
            echo "$1" | while IFS= read -r item; do
              if [[ "$item" =~ \<([^|]+)\|([^>]+)\> ]]; then
                # Format: <url|text>
                line "- [${BASH_REMATCH[2]}](${BASH_REMATCH[1]})"
              else
                # Plain text, possibly comma-separated
                echo "$item" | tr ',' '\n' | while IFS= read -r app; do
                  app=$(echo "$app" | xargs)  # trim whitespace
                  [[ -n "$app" ]] && line "- $app"
                done
              fi
            done
          }

          if [[ "$INITIAL_RESULT" != "success" ]]; then
            section "‚ùå Workflow Aborted - Initial Check Failed"
            line "Initial validation failed. Check the logs for details."
            exit 0
          fi

          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            section "üèÉ Dry Run Mode"
            print_stats
            if [[ "$CHECK_RESULT" == "success" ]]; then
              line "‚úÖ All $TOTAL_APPS applications validated successfully (dry run)."
            else
              line "‚ùå Some applications failed validation:"
              line "**Failed Applications:** $FAILED_APPS"
            fi
            exit 0
          fi

          if [[ "$CHECK_RESULT" == "failure" || "$UPDATE_RESULT" == "failure" ]]; then
            section "‚ö†Ô∏è Some Applications Failed"
            print_stats
          
            [[ "$CHECK_RESULT" == "failure" && "$SUCCESS_COUNT" -gt 0 ]] && { line "#### ‚úÖ Successfully checked:"; print_list "$SUCCESSFUL_APPS"; }
            [[ "$UPDATE_RESULT" == "failure" && "$SUCCESS_COUNT" -gt 0 ]] && { line "#### ‚úÖ Prepared:"; print_list "$PREPARED_APPS"; }
            [[ "$FAILURE_COUNT" -gt 0 ]] && { line "#### ‚ùå Failed:"; print_list "$FAILED_APPS"; }
            exit 0
          fi

          if [[ "$CHECK_RESULT" == "success" && "$UPDATE_RESULT" == "success" ]]; then
            section "‚úÖ All Applications Prepared Successfully"
            print_stats
            [[ -n "$PREPARED_APPS" ]] && { line "### üì¶ Prepared Applications"; print_list "$PREPARED_APPS"; }
          
            section "üéØ Platform Changes"
            if [[ "$PLATFORM_UPDATE_RESULT" == "success" ]]; then
              if [[ "$PLATFORM_COMMIT_RESULT" == "success" && -n "$PLATFORM_COMMIT_SHA" ]]; then
                line "- ‚úÖ Template updated to $PLATFORM_VERSION and committed ([${PLATFORM_COMMIT_SHA:0:7}](${{ github.server_url }}/${{ github.repository }}/commit/$PLATFORM_COMMIT_SHA))"
              elif [[ "$PLATFORM_COMMIT_RESULT" == "success" ]]; then
                line "- ‚úÖ Template updated to $PLATFORM_VERSION and committed"
              else
                line "- ‚ö†Ô∏è Template updated to $PLATFORM_VERSION but not committed"
              fi
            else
              line "- ‚ùå Template update failed or skipped"
            fi

            if [[ "$CONFIG_UPDATE_RESULT" == "success" ]]; then
              if [[ "$CONFIG_UPDATED" == "true" ]]; then
                if [[ "$CONFIG_COMMIT_RESULT" == "success" && -n "$CONFIG_COMMIT_SHA" ]]; then
                  line "- ‚úÖ Config updated and committed ([${CONFIG_COMMIT_SHA:0:7}](${{ github.server_url }}/${{ github.repository }}/commit/$CONFIG_COMMIT_SHA))"
                elif [[ "$CONFIG_COMMIT_RESULT" == "success" ]]; then
                  line "- ‚úÖ Config updated and committed"
                else
                  line "- ‚ö†Ô∏è Config updated but not committed"
                fi
              else
                line "- ‚ÑπÔ∏è Config already up-to-date (no changes needed)"
              fi
            else
              line "- ‚ùå Config update failed or skipped"
            fi
          
            exit 0
          fi

          section "‚ö†Ô∏è Unexpected Workflow State"
          line "- Initial: $INITIAL_RESULT"
          line "- Check: $CHECK_RESULT"
          line "- Update: $UPDATE_RESULT"
          line "- Collect: $COLLECT_RESULT"

          section "üì® Notification"
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            line "‚ÑπÔ∏è Slack notification skipped (dry run)"
          else
            case "$SLACK_OUTCOME" in
              success) line "‚úÖ Slack notification sent" ;;
              failure) line "‚ö†Ô∏è Slack notification failed (non-blocking)" ;;
              *)       line "‚ÑπÔ∏è Slack notification: $SLACK_OUTCOME" ;;
            esac
          fi
