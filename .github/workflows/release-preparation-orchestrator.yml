name: Release preparation orchestrator

on:
  workflow_dispatch:
    inputs:
      previous_release_branch:
        description: 'Previous release branch (e.g., R1-2024)'
        required: true
        type: string
      new_release_branch:
        description: 'New release branch (e.g., R2-2024)'
        required: true
        type: string
      new_applications:
        description: 'Comma, space, or newline-separated list of new applications to include in this release (e.g., app-new-feature,app-another)'
        required: false
        type: string
        default: ''
      use_snapshot_fallback:
        description: 'Use app snapshot branch if previous release branch not found'
        required: false
        type: boolean
        default: false
      use_snapshot_version:
        description: 'Use app snapshot version as a base version'
        required: false
        type: boolean
        default: false
      branch_name:
        description: 'Display name for the release branch (e.g., "FOLIO Sunflower Release")'
        required: false
        type: string
        default: ''
      branch_description:
        description: 'Description for the release branch'
        required: false
        type: string
        default: 'FOLIO LSP (Library Services Platform) is a set of microservices and applications that provide a complete library management system.'
      need_pr:
        description: 'Require PR for version updates on this branch'
        required: false
        type: boolean
        default: true
      prerelease_mode:
        description: 'PreRelease mode for version updates ("false", "true", or "only")'
        required: false
        type: string
        default: 'false'
      dry_run:
        description: 'Perform dry run without making changes'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

env:
  PLATFORM_TEMPLATE_FILE: 'platform.template.json'
  UPDATE_CONFIG_FILE: '.github/update-config.yml'
  UPDATE_CONFIG_TEMPLATE_PATH: '.github/templates/update-config.yml.template'

jobs:
  validate-actor:
    name: Validate Actor
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.validate-actor.outputs.authorized }}
    steps:
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}

      - name: Validate Actor
        id: validate-actor
        uses: folio-org/kitfox-github/.github/actions/validate-team-membership@master
        with:
          username: ${{ github.actor }}
          organization: 'folio-org'
          team: 'kitfox'
          token: ${{ steps.app-token.outputs.token }}

  approve-run:
    name: Approve Run
    needs: validate-actor
    runs-on: ubuntu-latest
    environment: Eureka CI
    if: needs.validate-actor.outputs.authorized == 'false'
    steps:
      - name: Run approvement
        run: |
          echo "::notice::This run was approved by $(
            gh api \
              /repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/approvals \
              --jq \
                '.[]
                | select(.environments[]?.name == "Eureka CI")
                | .user.login')"

  initial-check:
    name: Initial Check
    runs-on: ubuntu-latest
    needs: [ validate-actor, approve-run ]
    if: always() && (needs.validate-actor.outputs.authorized == 'true' || needs.approve-run.result == 'success')
    outputs:
      applications: ${{ steps.merge-applications.outputs.applications }}
      application_count: ${{ steps.merge-applications.outputs.application_count }}
      default_branch: ${{ steps.detect-default-branch.outputs.default_branch }}
    env:
      PREV_BRANCH: ${{ inputs.previous_release_branch }}
      NEW_BRANCH: ${{ inputs.new_release_branch }}
      FILE: "platform-descriptor.json"

    steps:
      - name: Input parameters
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call'
        env:
          INPUT_PARAMS: ${{ toJSON(github.event.inputs) }}
        run: |
          set -eo pipefail

          echo "::notice::Input parameters"
          echo ""
          echo "$INPUT_PARAMS" | jq '.'
          echo ""

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "::notice::This was a dry run - no actual changes were made"
            echo "::notice::Set dry_run=false to apply changes"
          fi

      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify Branches
        id: verify-branches
        run: |
          set -eo pipefail

          if ! git ls-remote --exit-code --heads origin "$PREV_BRANCH" >/dev/null 2>&1; then
            echo "::error::Missing branch. Previous release branch '$PREV_BRANCH' not found"
            exit 1
          fi

          if git ls-remote --exit-code --heads origin "$NEW_BRANCH" >/dev/null 2>&1; then
            echo "::error::New release branch '$NEW_BRANCH' already exists"
            exit 1
          fi

          echo "::notice::Previous release branch '$PREV_BRANCH' exists and new release branch '$NEW_BRANCH' does not exist"

      - name: Checkout Previous Release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.previous_release_branch }}
          fetch-depth: 0

      - name: Extract Existing Applications
        id: extract-applications
        run: |
          set -eo pipefail

          if [ ! -f "$FILE" ]; then
            echo "::error::$FILE not found in $PREV_BRANCH"
            exit 1
          fi

          existing_apps=$(jq -c '[.applications.required[]?, .applications.optional[]? | select(.name | startswith("app-")) | .name]' "$FILE")
          existing_count=$(jq -r 'length' <<<"$existing_apps")

          if ! [[ "$existing_count" -gt 0 ]]; then
            echo "::error::Could not find any applications in $FILE, or the file is malformed."
            exit 1
          fi

          echo "::notice::Descriptor verified. $FILE found in $PREV_BRANCH with $existing_count existing app(s)"
          jq -r '.[]' <<<"$existing_apps" | sed 's/^/  - /'
          echo "applications=$existing_apps" >> "$GITHUB_OUTPUT"
          echo "application_count=$existing_count" >> "$GITHUB_OUTPUT"

      - name: Parse New Applications
        id: parse-new-applications
        env:
          NEW_APPS: ${{ inputs.new_applications }}
        run: |
          set -eo pipefail
          IFS=$'\n\t'

          new_apps_json=$(jq -Rn -c --arg input "${NEW_APPS:-}" '
              $input
              | gsub("[,[:space:]]+"; "\n")   # turn every run of commas/white-space into a newline
              | split("\n")                   # split on those new-lines
              | map(select(length>0))         # drop blanks
              | unique                        # dedupe
              | sort                          # stable order
            ')

          new_count=$(jq 'length' <<<"$new_apps_json")

          echo "::notice::Found $new_count new application(s)"
          jq -r '.[]' <<<"$new_apps_json" | sed 's/^/  - /'
          echo "applications=$new_apps_json" >> "$GITHUB_OUTPUT"
          echo "application_count=$new_count" >> "$GITHUB_OUTPUT"

      - name: Merge Applications
        id: merge-applications
        env:
          EXISTING_APPS: ${{ steps.extract-applications.outputs.applications }}
          NEW_APPS:      ${{ steps.parse-new-applications.outputs.applications }}
        run: |
          set -eo pipefail
          IFS=$'\n\t'

          merged_apps=$(jq -c -n --argjson existing "$EXISTING_APPS" --argjson new "$NEW_APPS" '
              ( $existing + $new )                # concatenate
              | unique                            # remove dupes
              | sort                              # deterministic order
          ')

          total_count=$(jq 'length' <<<"$merged_apps")

          if (( total_count == 0 )); then
            echo "::error::No applications to process. After merging, list is empty."
            exit 1
          fi

          echo "::notice::Applications merged. $total_count total application(s)"
          echo "::group::Complete application list"
          jq -r '.[]' <<<"$merged_apps" | sed 's/^/  - /'
          echo "::endgroup::"

          echo "applications=$merged_apps"      >> "$GITHUB_OUTPUT"
          echo "application_count=$total_count" >> "$GITHUB_OUTPUT"

      - name: Detect Default Branch
        id: detect-default-branch
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -eo pipefail

          default_branch=$(gh api repos/${{ github.repository }} --jq .default_branch)
          if [ -z "$default_branch" ]; then
            echo "::error::Could not determine default branch for ${{ github.repository }}"
            exit 1
          fi

          echo "::notice::Default branch is: $default_branch"
          echo "default_branch=$default_branch" >> "$GITHUB_OUTPUT"

  check-applications:
    name: Check ${{ matrix.application }} Application
    needs: initial-check
    if: always() && needs.initial-check.result == 'success'
    strategy:
      matrix:
        application: ${{ fromJson(needs.initial-check.outputs.applications) }}
      fail-fast: false
      max-parallel: 10
    uses: folio-org/kitfox-github/.github/workflows/release-preparation-flow.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      app_name: ${{ matrix.application }}
      repo: folio-org/${{ matrix.application }}
      previous_release_branch: ${{ inputs.previous_release_branch }}
      new_release_branch: ${{ inputs.new_release_branch }}
      use_snapshot_fallback: ${{ inputs.use_snapshot_fallback }}
      use_snapshot_version: ${{ inputs.use_snapshot_version }}
      dry_run: true
    secrets: inherit

  update-applications:
    name: Prepare ${{ matrix.application }} Application
    needs: [initial-check, check-applications]
    if: always() && needs.check-applications.result == 'success' && inputs.dry_run != true
    strategy:
      matrix:
        application: ${{ fromJson(needs.initial-check.outputs.applications) }}
      fail-fast: false
      max-parallel: 10
    uses: folio-org/kitfox-github/.github/workflows/release-preparation-flow.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      app_name: ${{ matrix.application }}
      repo: folio-org/${{ matrix.application }}
      previous_release_branch: ${{ inputs.previous_release_branch }}
      new_release_branch: ${{ inputs.new_release_branch }}
      use_snapshot_fallback: ${{ inputs.use_snapshot_fallback }}
      use_snapshot_version: ${{ inputs.use_snapshot_version }}
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  collect-results:
    name: Collect Application Results
    needs: [initial-check, update-applications]
    runs-on: ubuntu-latest
    if: always() && needs.update-applications.result != 'skipped'
    outputs:
      failed_apps: ${{ steps.gather-failures.outputs.failed_apps }}
      success_count: ${{ steps.gather-failures.outputs.success_count }}
      failure_count: ${{ steps.gather-failures.outputs.failure_count }}
      prepared_apps: ${{ steps.gather-failures.outputs.prepared_apps }}
    steps:
      - name: Download All Application Results
        uses: actions/download-artifact@v4
        with:
          pattern: "result-*"
          path: /tmp/all-results
          merge-multiple: true

      - name: Gather Application Results
        id: gather-failures
        run: |
          set -eo pipefail

          echo "::notice::Analyzing application results"

          all=$(jq -s '.' /tmp/all-results/*.json)

          success_count=$(jq '[.[] | select(.status=="success")] | length' <<<"$all")
          failure_count=$(jq '[.[] | select(.status!="success")] | length' <<<"$all")
          failed_apps=$(jq -r '[.[] | select(.status!="success") | .application] | join(", ")' <<<"$all")

          prepared_apps=$(jq -r --arg base "${GITHUB_SERVER_URL}" --arg branch "${{ inputs.new_release_branch }}" '
            [.[]
              | select(.status=="success")
              | "<\($base)/folio-org/\(.application)/tree/\($branch)|\(.application) (\(.version))>"
            ]
            | join("\n")
          ' <<<"$all")

          echo "::notice::Results Summary - Success: $success_count, Failures: $failure_count"

          echo "failed_apps=$failed_apps" >> "$GITHUB_OUTPUT"
          echo "success_count=$success_count" >> "$GITHUB_OUTPUT"
          echo "failure_count=$failure_count" >> "$GITHUB_OUTPUT"
          {
            echo "prepared_apps<<EOF"
            printf '%s\n' "$prepared_apps"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  prepare-platform:
    name: Prepare Platform Template
    needs: [ initial-check, update-applications, collect-results ]
    runs-on: ubuntu-latest
    if: always() && needs.update-applications.result == 'success'
    outputs:
      platform_version: ${{ steps.update-platform-template.outputs.platform_version }}
    steps:
      - name: Checkout Platform Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.previous_release_branch }}
          fetch-depth: 0

      - name: Download Application Results
        uses: actions/download-artifact@v4
        with:
          pattern: "result-*"
          path: /tmp/app-results
          merge-multiple: true

      - name: Update Platform Template
        id: update-platform-template
        run: |
          set -eo pipefail

          if [ ! -f "$PLATFORM_TEMPLATE_FILE" ]; then
            echo "::error::$PLATFORM_TEMPLATE_FILE not found"
            exit 1
          fi

          echo "::notice::Dumping downloaded application result files"
          echo "::group::Application result artifacts"
          for f in /tmp/app-results/*.json; do
            echo "─── $f ───"
            cat "$f"
          done
          echo "::endgroup::"

          echo "::group::Current platform template"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          tmp=$(mktemp)
          results_file=$(mktemp)

          echo "::notice::Let's combine all application results into a single flat array"
          jq -s '.' /tmp/app-results/*.json > "$results_file"   # Combine all JSON files into a single array

          echo "::group::Combined application results"
          cat "$results_file"
          echo "::endgroup::"

          echo "::notice::Updating application versions with ^VERSION constraints and preRelease flags"
          jq --slurpfile results "$results_file" '
            reduce $results[0][] as $r (
              .;
              .applications.required |= map(
                if .name == $r.application then .version = ("^" + $r.version) | .preRelease = "false" else . end
              )
              | .applications.optional |= map(
                if .name == $r.application then .version = ("^" + $r.version) | .preRelease = "false" else . end
              )
            )
          ' "$PLATFORM_TEMPLATE_FILE" > "$tmp"

          rm "$results_file" && mv "$tmp" "$PLATFORM_TEMPLATE_FILE"

          echo "::group::Updated application versions"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          echo "::notice::Updating platform version and eureka-components with preRelease flags"
          tmp2=$(mktemp)
          jq --arg newVer "${{ inputs.new_release_branch }}" '
            .version = $newVer                                                            #update platform version to release branch
            | ."eureka-components" |= map(.version = "^VERSION" | .preRelease = "false")  #placeholder all eureka-component versions with preRelease
          ' "$PLATFORM_TEMPLATE_FILE" > "$tmp2" \
          && mv "$tmp2" "$PLATFORM_TEMPLATE_FILE"

          echo "::group::Updated platform template"
          cat "$PLATFORM_TEMPLATE_FILE"
          echo "::endgroup::"

          echo "platform_version=${{ inputs.new_release_branch }}" >> "$GITHUB_OUTPUT"

      - name: Upload Platform Template
        uses: actions/upload-artifact@v4
        with:
          name: platform-release-files
          path: ${{ env.PLATFORM_TEMPLATE_FILE }}
          retention-days: 1

  update-platform-config:
    name: Update Platform Configuration
    needs: [initial-check, prepare-platform]
    runs-on: ubuntu-latest
    outputs:
      config_updated: ${{ steps.update-config.outputs.updated }}

    steps:
      - name: Checkout Default Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.initial-check.outputs.default_branch }}
          fetch-depth: 1

      - name: Get or Create Update Config
        id: update-config
        env:
          NEW_BRANCH: ${{ inputs.new_release_branch }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          BRANCH_DESCRIPTION: ${{ inputs.branch_description }}
          NEED_PR: ${{ inputs.need_pr }}
          PRERELEASE_MODE: ${{ inputs.prerelease_mode }}
        run: |
          set -eo pipefail

          if [ -f "$UPDATE_CONFIG_FILE" ]; then
            echo "::notice::$UPDATE_CONFIG_FILE exists"
          else
            echo "::notice::$UPDATE_CONFIG_FILE not found, creating from template"

            git clone --depth 1 https://github.com/folio-org/platform-lsp.git /tmp/platform-lsp

            template_path="/tmp/platform-lsp/$UPDATE_CONFIG_TEMPLATE_PATH"
            if [ ! -f "$template_path" ]; then
              echo "::error::Template not found at $template_path"
              exit 1
            fi

            mkdir -p "$(dirname "$UPDATE_CONFIG_FILE")"
            cp "$template_path" "$UPDATE_CONFIG_FILE"
          fi

          if yq eval ".branches[] | select(. == \"$NEW_BRANCH\" or .\"$NEW_BRANCH\")" "$UPDATE_CONFIG_FILE" | grep -q "$NEW_BRANCH"; then
            echo "::notice::Branch $NEW_BRANCH already in config, no update needed"
            echo "updated=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          branch_config=$(jq -n \
            --arg branch "$NEW_BRANCH" \
            --arg name "$BRANCH_NAME" \
            --arg desc "$BRANCH_DESCRIPTION" \
            --argjson need_pr "$NEED_PR" \
            --arg prerelease "$PRERELEASE_MODE" \
            '{
              ($branch): {
                enabled: true,
                need_pr: $need_pr,
                preRelease: $prerelease
              }
              | (if $name != "" then . + {name: $name} else . end)
              | (if $desc != "" then . + {description: $desc} else . end)
            }')

          echo "::notice::Adding branch configuration:"
          echo "$branch_config" | jq .

          yq eval ".branches += [$branch_config]" -i "$UPDATE_CONFIG_FILE"

          echo "::group::Updated config"
          cat "$UPDATE_CONFIG_FILE"
          echo "::endgroup::"

          echo "updated=true" >> "$GITHUB_OUTPUT"

      - name: Prepare Config for Upload
        if: steps.update-config.outputs.updated == 'true'
        run: |
          set -eo pipefail

          echo "::notice::Preparing config file for artifact upload"
          artifact_dir="/tmp/config-artifact"
          mkdir -p "$artifact_dir/$(dirname "$UPDATE_CONFIG_FILE")"
          cp "$UPDATE_CONFIG_FILE" "$artifact_dir/$UPDATE_CONFIG_FILE"

          echo "::group::Artifact structure"
          find "$artifact_dir" -type f
          echo "::endgroup::"

      - name: Upload Config File
        if: steps.update-config.outputs.updated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: platform-config-file
          path: /tmp/config-artifact/
          include-hidden-files: true
          retention-days: 1

  commit-platform-changes:
    name: Commit Platform Release Branch
    needs: [initial-check, prepare-platform]
    if: needs.prepare-platform.result == 'success' && inputs.dry_run != true
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      repo: ${{ github.repository }}
      branch: ${{ inputs.new_release_branch }}
      source_branch: ${{ inputs.previous_release_branch }}
      artifact_name: platform-release-files
      commit_message: |
        Prepare platform for release. Initial commit.

        Previous release: ${{ inputs.previous_release_branch }}
        New release: ${{ inputs.new_release_branch }}
        Applications processed: ${{ needs.initial-check.outputs.application_count }}

        Application versions set to ^VERSION constraints.
        Eureka component versions set to ^VERSION placeholder.
      deleted_files: |
        platform-descriptor.json
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  commit-platform-config:
    name: Commit Platform Config to Default Branch
    needs: [initial-check, update-platform-config, commit-platform-changes]
    if: needs.update-platform-config.outputs.config_updated == 'true' && needs.commit-platform-changes.result == 'success' && inputs.dry_run == false
    uses: folio-org/kitfox-github/.github/workflows/commit-and-push-changes.yml@RANCHER-2572-test #TODO: Switch back to master
    with:
      repo: ${{ github.repository }}
      branch: ${{ needs.initial-check.outputs.default_branch }}
      artifact_name: platform-config-file
      commit_message: |
        Add ${{ inputs.new_release_branch }} to platform update configuration

        Automatically added by release preparation workflow.
      dry_run: ${{ inputs.dry_run }}
    secrets: inherit

  slack_notification:
    name: Slack Notification
    runs-on: ubuntu-latest
    needs: [ initial-check, check-applications, update-applications, collect-results, prepare-platform, commit-platform-changes, commit-platform-config ]
    if: always() && inputs.dry_run == false && needs.check-applications.result == 'success'
    outputs:
      notification_outcome: ${{ steps.send-success.outcome || steps.send-failure.outcome }}
    env:
      IS_SUCCESS: >-
        ${{
            needs.update-applications.result == 'failure' && 'false' ||
            needs.prepare-platform.result == 'failure' && 'false' ||
            needs.commit-platform-changes.result == 'failure' && 'false' ||
            'true'
        }}
      PREPARED_APPS: ${{ needs.collect-results.outputs.prepared_apps }}
    steps:
      - name: Prepare Multiline Strings
        id: prepare-multiline
        run: |
          set -eo pipefail

          echo "::notice::Build prepared applications info string"
          echo "prepared_applications<<EOF"$'\n'"$PREPARED_APPS"$'\n'EOF >> "$GITHUB_OUTPUT"

      - name: Send SUCCESS Slack Notification
        id: send-success
        if: env.IS_SUCCESS == 'true'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.EUREKA_CI_SLACK_BOT_TOKEN }}
          errors: true
          payload: |
            channel: "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}"
            text: "Platform Release Preparation SUCCESS"
            blocks:
              - type: section
                text:
                  type: mrkdwn
                  text: "*Platform Release Preparation SUCCESS <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>*"
            attachments:
              - color: "good"
                fields:
                  - title: "New Release"
                    value: "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }}|${{ inputs.new_release_branch }}>"
                    short: true
                  - title: "Previous Release"
                    value: "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }}|${{ inputs.previous_release_branch }}>"
                    short: true
                  - title: "Applications Processed"
                    value: "${{ needs.initial-check.outputs.application_count }}"
                    short: true
                  - title: "Commit"
                    value: "<${{ github.server_url }}/${{ github.repository }}/commit/${{ needs.commit-platform-changes.outputs.commit_sha }}|${{ needs.commit-platform-changes.outputs.commit_sha }}>"
                    short: true
              - color: "good"
                mrkdwn_in: ["text"]
                text: ${{ toJSON(steps.prepare-multiline.outputs.prepared_applications) }}
                footer: "Eureka CI/CD"

      - name: Send FAILED Slack Notification
        id: send-failure
        if: env.IS_SUCCESS == 'false'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.EUREKA_CI_SLACK_BOT_TOKEN }}
          errors: true
          payload: |
            channel: "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}"
            text: "Platform Release Preparation FAILED"
            blocks:
              - type: section
                text:
                  type: mrkdwn
                  text: "*Platform Release Preparation FAILED <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>*"
              - type: section
                text:
                  type: mrkdwn
                  text: >-
                    ${{
                      needs.update-applications.result == 'failure' &&
                        format(
                          'Reason: application preparation
                     Failed app(s): {0}',
                          needs.collect-results.outputs.failed_apps || 'Unknown'
                        )
                      ||
                      'Reason: platform preparation'
                    }}
            attachments:
              - color: "danger"
                fields:
                  - title: "New Release"
                    value: "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }}|${{ inputs.new_release_branch }}>"
                    short: true
                  - title: "Previous Release"
                    value: "<${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }}|${{ inputs.previous_release_branch }}>"
                    short: true
                  - title: "Applications Successfully Processed"
                    value: "${{ needs.collect-results.outputs.success_count }}"
                    short: true
                  - title: "Applications Failed"
                    value: "${{ needs.collect-results.outputs.failure_count }}"
                    short: true
                footer: "Eureka CI/CD"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [initial-check, check-applications, update-applications, collect-results, prepare-platform, commit-platform-changes, commit-platform-config, slack_notification]
    if: always()
    steps:
      - name: Generate Workflow Summary
        env:
          TOTAL_APPS: ${{ needs.initial-check.outputs.application_count }}
          SUCCESS_COUNT: ${{ needs.collect-results.outputs.success_count || '0' }}
          FAILURE_COUNT: ${{ needs.collect-results.outputs.failure_count || '0' }}
          FAILED_APPS: ${{ needs.collect-results.outputs.failed_apps }}
          PREPARED_APPS: ${{ needs.collect-results.outputs.prepared_apps }}
          PLATFORM_VERSION: ${{ needs.prepare-platform.outputs.platform_version }}
          COMMIT_SHA: ${{ needs.commit-platform-changes.outputs.commit_sha }}
          CONFIG_UPDATED: ${{ needs.commit-platform-config.outputs.config_updated }}
          SLACK_NOTIF_OUTCOME: ${{ needs.slack_notification.outputs.notification_outcome }}
          SLACK_NOTIF_STATUS_ICON: >-
            ${{
              needs.slack_notification.outputs.notification_outcome == 'success' && '✅'
              || needs.slack_notification.outputs.notification_outcome == 'failure' && '⚠️'
              || 'ℹ️'
            }}
        run: |
          {
            echo "## 🚀 Platform Release Preparation Summary"
            echo ""
            echo "### 📊 Overall Statistics"
            echo "- **Previous Release**: [\`${{ inputs.previous_release_branch }}\`](${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.previous_release_branch }})"
            echo "- **New Release**: [\`${{ inputs.new_release_branch }}\`](${{ github.server_url }}/${{ github.repository }}/tree/${{ inputs.new_release_branch }})"
            echo "- **Total Applications**: $TOTAL_APPS"
            echo "- **Triggered by**: ${{ github.actor }}"
            echo "- **Run Number**: ${{ github.run_number }}"
            echo ""

            # Check if this is a dry run first
            if [[ "${{ inputs.dry_run }}" == "true" ]]; then
              echo "### 🏃 Dry Run Mode"
              echo ""
              echo "This was a dry run to validate the release preparation process."
              echo "- Application branches were checked but not created"
              echo "- Platform template was validated but not committed"
              echo "- No actual changes were made to any repositories"
              echo ""
              echo "Set \`dry_run=false\` to apply changes."
              echo ""

            elif [[ "${{ needs.check-applications.result }}" == "success" && "${{ needs.update-applications.result }}" == "success" ]]; then
              echo "- **Successfully Prepared**: $SUCCESS_COUNT"
              echo "- **Failed Applications**: $FAILURE_COUNT"
              echo ""
              echo "### ✅ All Applications Prepared Successfully"
              echo ""

              if [[ "$SUCCESS_COUNT" -gt 0 ]]; then
                echo "### 📦 Prepared Applications"
                echo ""
                echo "$PREPARED_APPS" | while IFS= read -r line; do
                  if [[ "$line" =~ \<([^|]+)\|([^>]+)\> ]]; then
                    url="${BASH_REMATCH[1]}"
                    text="${BASH_REMATCH[2]}"
                    echo "- [$text]($url)"
                  fi
                done
                echo ""
              fi

              echo "### 🎯 Platform Changes"
              if [[ -n "$COMMIT_SHA" ]]; then
                echo "- **Platform Template**: Updated to $PLATFORM_VERSION"
                echo "- **Commit**: [\`${COMMIT_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/$COMMIT_SHA)"
              else
                echo "- No platform changes committed (dry run or error)"
              fi

              if [[ "$CONFIG_UPDATED" == "true" ]]; then
                echo "- **Update Config**: Added ${{ inputs.new_release_branch }} to update-config.yml"
              else
                echo "- **Update Config**: No changes needed (branch already configured)"
              fi
              echo ""

            elif [[ "${{ needs.check-applications.result }}" == "skipped" || "${{ needs.update-applications.result }}" == "skipped" ]]; then
              echo "### ⏭️ Preparation Skipped"
              echo "The preparation process was skipped. This may be due to:"
              echo "- Authorization check failure"
              echo "- Initial validation failed"
              echo "- Conditional logic"
              echo ""

            else
              echo "- **Successfully Prepared**: $SUCCESS_COUNT"
              echo "- **Failed Applications**: $FAILURE_COUNT"
              echo ""
              echo "### ⚠️ Some Applications Failed to Prepare"
              echo ""

              if [[ "$SUCCESS_COUNT" -gt 0 ]]; then
                echo "#### ✅ Successfully Prepared: $SUCCESS_COUNT applications"
                echo ""
                echo "**Prepared Applications:**"
                echo "$PREPARED_APPS" | while IFS= read -r line; do
                  if [[ "$line" =~ \<([^|]+)\|([^>]+)\> ]]; then
                    url="${BASH_REMATCH[1]}"
                    text="${BASH_REMATCH[2]}"
                    echo "- [$text]($url)"
                  fi
                done
                echo ""
              fi

              if [[ -n "$FAILED_APPS" ]]; then
                echo "#### ❌ Failed Applications: $FAILED_APPS"
                echo ""
              fi

              echo "### 🔧 Troubleshooting"
              echo "- Check individual application workflow logs for detailed error information"
              echo "- Verify previous release branches exist and are accessible"
              echo "- Ensure GitHub App has proper permissions for all repositories"
              echo "- Check that application.template.json files exist in previous release branches"
              echo "- Verify Maven pom.xml files are properly formatted (if present)"
              echo ""
            fi

            echo "### 🔄 Workflow Options Used"
            echo "- **Previous Release Branch:** ${{ inputs.previous_release_branch }}"
            echo "- **New Release Branch:** ${{ inputs.new_release_branch }}"
            echo "- **Use Snapshot Fallback:** ${{ inputs.use_snapshot_fallback }}"
            echo "- **Use Snapshot Version:** ${{ inputs.use_snapshot_version }}"
            echo "- **Branch Name:** ${{ inputs.branch_name || '(not specified)' }}"
            echo "- **Need PR:** ${{ inputs.need_pr }}"
            echo "- **PreRelease Mode:** ${{ inputs.prerelease_mode }}"
            echo "- **Dry Run:** ${{ inputs.dry_run }}"
            echo "- **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

            echo ""
            echo "### 📨 Notification Status"
            echo ""

            if [[ "${{ inputs.dry_run }}" == "true" ]]; then
              echo "ℹ️ **Slack Notification:** Skipped (dry run mode)"
            elif [[ -n "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}" ]]; then
              if [[ "$SLACK_NOTIF_OUTCOME" == "success" ]]; then
                echo "$SLACK_NOTIF_STATUS_ICON **Slack Notification:** Successfully sent to ${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}"
              elif [[ "$SLACK_NOTIF_OUTCOME" == "failure" ]]; then
                echo "$SLACK_NOTIF_STATUS_ICON **Slack Notification:** Failed to send (non-blocking error)"
              else
                echo "$SLACK_NOTIF_STATUS_ICON **Slack Notification:** $SLACK_NOTIF_OUTCOME"
              fi
            else
              echo "ℹ️ **Slack Notification:** Not configured"
            fi

            echo ""
            echo "---"
            echo "*Workflow completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')*"
          } >> "$GITHUB_STEP_SUMMARY"